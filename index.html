<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Integrated Inductance Analysis Tool (L_initial Logic)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family: 'Arial', sans-serif; background:#f5f5f5; padding:20px; }
        .container { max-width:1000px; margin:0 auto; background:#fff; border-radius:10px; padding:30px; box-shadow:0 2px 10px rgba(0,0,0,.1); }
        .title { font-size:28px; font-weight:700; color:#333; margin-bottom:30px; text-align:center; }
        .section { margin-bottom:30px; }
        .section-title { font-size:20px; font-weight:700; color:#444; margin-bottom:15px; border-bottom:2px solid #007bff; padding-bottom:5px; }
        .data-input { width:100%; height:250px; padding:15px; border:2px solid #ddd; border-radius:8px; font-family:'Courier New', monospace; font-size:12px; resize:vertical; }
        .controls { display:grid; grid-template-columns:repeat(auto-fit, minmax(200px,1fr)); gap:20px; background:#f8f9fa; padding:20px; border-radius:8px; }
        .control-group { display:flex; flex-direction:column; }
        .control-group label { font-weight:700; margin-bottom:6px; color:#555; }
        .control-group select { padding:8px; border:1px solid #ccc; border-radius:5px; font-size:14px; }
        .chart-container { position:relative; height:500px; margin:20px 0; background:#fff; border:1px solid #ddd; border-radius:8px; padding:20px; }
        #chartStatus { position:absolute; top:10px; right:10px; background:rgba(0,0,0,.7); color:#fff; padding:5px 10px; border-radius:5px; font-size:14px; display:none; }
        .table-wrapper { max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; margin-top: 15px; }
        .stats-table { width:100%; border-collapse:collapse; background:#fff; font-size:13px; }
        .stats-table th, .stats-table td { padding:8px; text-align:center; border-bottom:1px solid #eee; }
        .stats-table th { background:#007bff; color:#fff; font-weight:700; font-size:11px; position: sticky; top: 0; z-index: 1; }
        .stats-table tr:nth-child(even){ background:#f8f9fa; }
        .stats-table tr:hover{ background:#e3f2fd; }
        .data-count { background:#28a745; color:#fff; padding:5px 10px; border-radius:15px; font-size:12px; margin-top:10px; display:inline-block; }
        .btn { background:#007bff; color:#fff; border:none; padding:12px 25px; border-radius:8px; cursor:pointer; font-size:16px; margin:5px; transition: background-color 0.3s ease; }
        .btn:hover{ background:#0056b3; }
        .btn-secondary{ background:#6c757d; }
        .btn-secondary:hover{ background:#545b62; }
        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; background-color: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #ddd; max-height: 200px; overflow-y: auto; }
        .filter-item { display: flex; align-items: center; background: #fff; padding: 8px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-size: 13px; }
        .filter-item input { margin-right: 10px; }
        .filter-item label { display: flex; align-items: center; cursor: pointer; flex: 1; }
        .filter-actions { margin-bottom: 10px; }
        .btn-filter { background: #6c757d; color: white; border: none; padding: 5px 10px; font-size: 12px; border-radius: 4px; cursor: pointer; margin-right: 5px; }
        .btn-filter:hover { background: #5a6268; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">🚀 Integrated Inductance Analysis Tool (L_initial Logic)</h1>
        
        <div class="section">
            <h2 class="section-title">Step 1: Paste Raw Data</h2>
            <textarea id="rawInput" class="data-input">
BLOCK: 6x15x5, N: 27
Idc(A)	211	212
0	56.8	51.6
10	54	49
20	48.8	43.8
30	42.8	38
40	36.5	32.8
50	31.5	28.5
60	27.5	25
70	24.5	22
L_initial	57.3	52.0

BLOCK: 6x15x5, N: 26
Idc(A)	211	212
0	52.4	47.6
10	49.8	45.2
20	45	40.5
30	39.5	35.5
40	34	30.8
50	29.5	26.8
60	26	23.5
70	23	21
L_initial	52.8	48.0

BLOCK: 6x15x5, N: 25
Idc(A)	211	212
0	48.4	44
10	46	41.8
20	41.5	37.5
30	36.5	33
40	31.5	28.8
50	27.5	25.2
60	24.5	22.5
L_initial	48.7	44.3

BLOCK: 6x15x5, N: 24
Idc(A)	211	212
0	44.6	40.5
10	42.5	38.5
20	38.5	34.8
30	34	30.8
40	29.5	26.8
50	26	23.8
60	23	21.2
L_initial	44.9	40.8

BLOCK: 6x15x5, N: 23
Idc(A)	211	212
0	41.1	37.2
10	39	35.2
20	35.5	32
30	31.2	28
40	27.2	24.5
50	24	21.8
L_initial	41.3	37.5

BLOCK: 6x15x5, N: 22
Idc(A)	211	212
0	37.8	34.2
10	36	32.5
20	32.5	29.2
30	28.8	25.8
40	25.2	22.8
50	22.2	20.2
L_initial	38.0	34.5

BLOCK: 6x15x5, N: 21
Idc(A)	211	212
0	34.7	31.5
10	33	29.8
20	30	27
30	26.5	23.8
40	23.2	21
50	20.5	18.5
L_initial	34.9	31.7

BLOCK: 6x15x5, N: 20
Idc(A)	211	212
0	31.8	28.8
10	30.2	27.2
20	27.5	24.8
30	24.2	21.8
40	21.2	19.2
L_initial	32.0	29.0

BLOCK: 6x15x5, N: 19
Idc(A)	211	212
0	29.1	26.4
10	27.8	25
20	25.2	22.8
30	22.2	20
40	19.5	17.8
L_initial	29.3	26.6

BLOCK: 6x15x5, N: 18
Idc(A)	211	212
0	26.6	24
10	25.2	22.8
20	23	20.8
30	20.2	18.2
L_initial	26.7	24.2

BLOCK: 6x15x5, N: 17
Idc(A)	211	212
0	24.2	21.9
10	23	20.8
20	21	18.9
30	18.5	16.7
L_initial	24.4	22.1

BLOCK: 6x15x5, N: 16
Idc(A)	211	212
0	22.1	20
10	21	19
20	19.1	17.2
30	16.8	15.2
L_initial	22.2	20.1

BLOCK: 6x15x5, N: 15
Idc(A)	211	212
0	20.1	18.2
10	19.1	17.2
20	17.5	15.8
L_initial	20.2	18.3

BLOCK: 6x15x5, N: 14
Idc(A)	211	212
0	18.2	16.5
10	17.2	15.6
20	15.8	14.3
L_initial	18.3	16.6

BLOCK: 7x22x5, N: 36
Idc(A)	211	212	217	218	219	220	221	222
0	92	83	82	73.5	71.2	70.8	69	68.5
10	87.5	79	78	69.5	67.5	67	65.5	65
20	80.5	72.5	71.5	63.5	61.5	61	59.5	59
30	71.5	64.5	63.5	56.5	54.5	54.2	53	52.5
40	62	56	55	49	47.5	47.2	46	45.8
50	53	48	47	42	40.8	40.5	39.5	39.2
60	45.5	41.5	40.5	36.2	35	34.8	34	33.8
70	39.5	36.2	35.5	31.8	30.8	30.5	29.8	29.5
80	34.8	32	31.2	28.2	27.2	27	26.5	26.2
L_initial	92.8	83.5	82.5	74.0	71.8	71.2	69.5	69.0

BLOCK: 7x22x5, N: 35
Idc(A)	211	212	217	218	219	220	221	222
0	87	78.5	77.5	69.5	67.2	66.8	65	64.5
10	82.5	74.5	73.5	66	63.8	63.2	61.8	61.2
20	75.5	68.5	67.5	60.5	58.5	58	56.8	56.2
30	67	61	60	54	52.2	51.8	50.5	50
40	58.5	53	52.2	47	45.5	45	44.2	43.8
50	50.5	46	45.2	40.5	39.2	38.8	38	37.8
60	43.8	40	39.2	35.2	34.2	33.8	33	32.8
70	38.2	35	34.2	31	30	29.8	29	28.8
80	33.8	31	30.2	27.2	26.5	26.2	25.8	25.5
L_initial	87.5	79.0	78.0	70.0	67.8	67.2	65.5	65.0

BLOCK: 7x22x5, N: 34
Idc(A)	211	212	217	218	219	220	221	222
0	82.2	74.2	73.2	65.5	63.5	63	61.5	61
10	78	70.5	69.5	62.2	60.2	59.8	58.2	57.8
20	71.5	64.8	63.8	57.2	55.2	54.8	53.5	53
30	63.5	57.8	56.8	51	49.5	49	48	47.5
40	55.5	50.5	49.8	44.8	43.5	43	42.2	41.8
50	48.2	44	43.2	39	37.8	37.5	36.8	36.5
60	42	38.2	37.5	34	33	32.8	32	31.8
70	36.8	33.8	33	30	29	28.8	28.2	28
80	32.5	29.8	29.2	26.5	25.8	25.5	25	24.8
L_initial	82.8	74.8	73.8	66.0	64.0	63.5	62.0	61.5

BLOCK: 7x22x5, N: 33
Idc(A)	211	212	217
0	77.8	70.2	69.2
10	74	66.8	65.8
20	67.5	61	60
30	60	54.5	53.5
40	52.5	47.8	47
50	45.8	41.8	41
60	40	36.8	36
70	35.2	32.5	32
80	31	29	28.2
L_initial	78.3	70.8	69.8

BLOCK: 7x22x5, N: 32
Idc(A)	211	212	217
0	73.5	66.5	65.5
10	70	63.2	62.2
20	64	57.8	56.8
30	57	51.8	50.8
40	50	45.5	44.8
50	43.8	40	39.2
60	38.2	35.2	34.5
70	33.8	31.2	30.5
80	29.8	27.8	27
L_initial	74.0	67.0	66.0

BLOCK: 7x22x5, N: 31
Idc(A)	211	212	217
0	69.5	62.8	61.8
10	66.2	59.8	58.8
20	60.5	54.8	53.8
30	54	49	48
40	47.5	43.2	42.2
50	41.5	38	37.2
60	36.5	33.5	32.8
70	32.2	29.8	29
L_initial	70.0	63.2	62.2

BLOCK: 7x22x5, N: 30
Idc(A)	211	212	217
0	65.8	59.5	58.5
10	62.5	56.5	55.5
20	57.2	51.8	50.8
30	51	46.2	45.2
40	44.8	40.8	40
50	39.2	35.8	35
60	34.8	31.8	31
70	30.8	28.2	27.5
L_initial	66.2	60.0	59.0

BLOCK: 7x22x5, N: 29
Idc(A)	211	212	217
0	62.2	56.2	55.2
10	59	53.5	52.5
20	54	49	48
30	48.2	43.8	42.8
40	42.5	38.5	37.8
50	37.2	34	33.2
60	32.8	30	29.2
L_initial	62.6	56.6	55.6

BLOCK: 7x22x5, N: 28
Idc(A)	211	212	217
0	58.8	53	52
10	56	50.5	49.5
20	51	46.2	45.2
30	45.5	41.2	40.2
40	40	36.5	35.8
50	35.2	32	31.2
60	31	28.2	27.5
L_initial	59.2	53.4	52.4

BLOCK: 7x22x5, N: 27
Idc(A)	211	212	217
0	55.5	50	49
10	52.8	47.5	46.5
20	48.2	43.5	42.5
30	43	39	38
40	38	34.5	33.8
50	33.5	30.5	29.8
L_initial	55.8	50.3	49.3

BLOCK: 7x22x5, N: 26
Idc(A)	211	212	217
0	52.5	47.2	46.2
10	50	45	44
20	45.8	41.2	40.2
30	40.8	36.8	35.8
40	36	32.5	31.8
L_initial	52.8	47.5	46.5
</textarea>
            <div style="text-align: center; margin-top: 20px;">
                <button id="processBtn" class="btn">📊 Process and Analyze Data</button>
            </div>
             <div id="processingErrors" style="margin-top:15px; font-size:13px; color:#c00; font-family:'Courier New', monospace;"></div>
        </div>

        <textarea id="dataInput" class="data-input hidden"></textarea>

        <div id="analysisContainer" class="hidden">
            <hr style="margin: 40px 0;">
            <h2 class="section-title" style="text-align: center; font-size: 24px; border-bottom: none;">Step 2: Analysis Results</h2>
            <div class="section">
                <h2 class="section-title">Parsed Data Confirmation</h2>
                <div id="dataCount" class="data-count">Waiting for data...</div>
                <div class="table-wrapper">
                    <table class="stats-table" id="parsedDataTable">
                        <thead>
                            <tr>
                                <th>Center Leg</th><th>Outer Shell</th><th>L_initial(uH)</th><th>Idc_70%(A)</th><th>Idc_80%(A)</th><th>Gap(mm)</th><th>N</th><th>FoM</th>
                            </tr>
                        </thead>
                        <tbody id="parsedDataTableBody"></tbody>
                    </table>
                </div>
            </div>
            <div class="section">
                <h2 class="section-title">Center Leg Core Filter</h2>
                <div class="filter-actions">
                    <button class="btn-filter" id="selectAllCenterLegs">Select All</button>
                    <button class="btn-filter" id="deselectAllCenterLegs">Deselect All</button>
                </div>
                <div class="filter-controls" id="centerLegFilterControls"></div>
            </div>
            <div class="section">
                <h2 class="section-title">Outer Core Shell Filter</h2>
                <div class="filter-actions">
                    <button class="btn-filter" id="selectAllOuterCores">Select All</button>
                    <button class="btn-filter" id="deselectAllOuterCores">Deselect All</button>
                </div>
                <div class="filter-controls" id="outerCoreFilterControls"></div>
            </div>
            <div class="section">
                <h2 class="section-title">Analysis Options</h2>
                <div class="controls">
                    <div class="control-group"><label for="xAxis">X-Axis</label><select id="xAxis"><option value="Idc_80">Idc 80% (A)</option><option value="Idc_70">Idc 70% (A)</option><option value="L_initial">Inductance (μH)</option><option value="FoM">FoM (L×Idc)</option><option value="Gap">Gap (mm)</option></select></div>
                    <div class="control-group"><label for="yAxis">Y-Axis</label><select id="yAxis"><option value="L_initial">Inductance (μH)</option><option value="Idc_80">Idc 80% (A)</option><option value="Idc_70">Idc 70% (A)</option><option value="FoM">FoM (L×Idc)</option><option value="Gap">Gap (mm)</option></select></div>
                    <div class="control-group"><label>&nbsp;</label><button class="btn btn-secondary" id="btnExportCSV">Export Selected Data to CSV</button></div>
                    <div class="control-group"><label>&nbsp;</label><button class="btn btn-secondary" id="btnExportPNG">Export Chart to PNG</button></div>
                </div>
            </div>
            <div class="section">
                <h2 class="section-title">Analysis Chart</h2>
                <div class="chart-container"><canvas id="mainChart"></canvas><div id="chartStatus">Loading...</div></div>
            </div>
            <div class="section">
                <h2 class="section-title">Statistics Summary (Based on selected data)</h2>
                <div class="table-wrapper" style="max-height: none;">
                    <table class="stats-table" id="statsTable">
                        <thead><tr><th>Group (Center Leg)</th><th>Count</th><th>L Avg (μH)</th><th>Idc_70% Avg (A)</th><th>Idc_80% Avg (A)</th><th>FoM Avg</th><th>Gap Avg (mm)</th></tr></thead>
                        <tbody id="statsTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

<script>
// --- START: Calculation Logic (Interpolation/Extrapolation) ---
class CubicSpline {
    constructor(x, y) { this.x = [...x]; this.y = [...y]; this.n = x.length; this.calculateCoefficients(); }
    calculateCoefficients() { const n = this.n; const h = new Array(n - 1); for (let i = 0; i < n - 1; i++) h[i] = this.x[i + 1] - this.x[i]; const alpha = new Array(n - 1); for (let i = 1; i < n - 1; i++) alpha[i] = (3 / h[i]) * (this.y[i + 1] - this.y[i]) - (3 / h[i - 1]) * (this.y[i] - this.y[i - 1]); const l = new Array(n); const mu = new Array(n); const z = new Array(n); l[0] = 1; mu[0] = 0; z[0] = 0; for (let i = 1; i < n - 1; i++) { l[i] = 2 * (this.x[i + 1] - this.x[i - 1]) - h[i - 1] * mu[i - 1]; mu[i] = h[i] / l[i]; z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i]; } l[n - 1] = 1; z[n - 1] = 0; this.c = new Array(n); this.b = new Array(n - 1); this.d = new Array(n - 1); this.c[n - 1] = 0; for (let j = n - 2; j >= 0; j--) { this.c[j] = z[j] - mu[j] * this.c[j + 1]; this.b[j] = (this.y[j + 1] - this.y[j]) / h[j] - h[j] * (this.c[j + 1] + 2 * this.c[j]) / 3; this.d[j] = (this.c[j + 1] - this.c[j]) / (3 * h[j]); } }
    interpolate(x) { if (x < this.x[0] || x > this.x[this.n-1]) return null; let i = 0; for (i = 0; i < this.n - 1; i++) if (x <= this.x[i + 1]) break; const dx = x - this.x[i]; return this.y[i] + this.b[i] * dx + this.c[i] * dx * dx + this.d[i] * dx * dx * dx; }
    findX(targetY, tolerance = 0.001) { let left = this.x[0], right = this.x[this.n - 1]; let iterations = 0; const maxIterations = 200; while (right - left > tolerance && iterations < maxIterations) { const mid = (left + right) / 2; const midY = this.interpolate(mid); if (midY === null) return { value: null }; if (midY > targetY) left = mid; else right = mid; iterations++; } const finalValue = (left + right) / 2; return { value: finalValue, isExtrapolated: false }; }
}
function polynomialRegression(x, y) { const n = x.length; let sumX = 0, sumY = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0, sumXY = 0, sumX2Y = 0; for (let i = 0; i < n; i++) { sumX += x[i]; sumY += y[i]; sumX2 += x[i] * x[i]; sumX3 += x[i] * x[i] * x[i]; sumX4 += x[i] * x[i] * x[i] * x[i]; sumXY += x[i] * y[i]; sumX2Y += x[i] * x[i] * y[i]; } const SXX = sumX2 - sumX * sumX / n; const SXY = sumXY - sumX * sumY / n; const SXX2 = sumX3 - sumX * sumX2 / n; const SX2Y = sumX2Y - sumX2 * sumY / n; const SX2X2 = sumX4 - sumX2 * sumX2 / n; const denominator = (SX2X2 * SXX - SXX2 * SXX2); if (Math.abs(denominator) < 1e-10) return null; const a = (SX2Y * SXX - SXY * SXX2) / denominator; const b = (SXY * SX2X2 - SX2Y * SXX2) / denominator; const c = sumY / n - b * sumX / n - a * sumX2 / n; const yMean = sumY / n; let sst = 0, sse = 0; for (let i = 0; i < n; i++) { sst += (y[i] - yMean) * (y[i] - yMean); const predictedY = a * x[i] * x[i] + b * x[i] + c; sse += (y[i] - predictedY) * (y[i] - predictedY); } const r2 = 1 - (sse / sst); return { coefficients: [a, b, c], r2 }; }
function solveQuadratic(a, b, c, context, range) { const discriminant = b * b - 4 * a * c; if (discriminant < 0) return null; const root1 = (-b + Math.sqrt(discriminant)) / (2 * a); const root2 = (-b - Math.sqrt(discriminant)) / (2 * a); if (context === 'upper') { return root1 > range[1] ? root1 : (root2 > range[1] ? root2 : null); } if (context === 'lower') { return root1 < range[0] ? root1 : (root2 < range[0] ? root2 : null); } return null; }
function findIdcForTarget(idcValues, inductanceValues, targetPercentage) { const initialInductance = inductanceValues[0]; if (initialInductance === 0) return null; const normalizedInductance = inductanceValues.map(val => (val / initialInductance) * 100); const minInductance = Math.min(...normalizedInductance); const maxInductance = Math.max(...normalizedInductance); let resultIdc = null; if (targetPercentage >= minInductance && targetPercentage <= maxInductance) { const spline = new CubicSpline(idcValues, normalizedInductance); const splineResult = spline.findX(targetPercentage); resultIdc = splineResult.value; } else { const regression = polynomialRegression(idcValues, normalizedInductance); if (regression && regression.r2 >= 0.95) { const [a, b, c] = regression.coefficients; const c_prime = c - targetPercentage; const context = targetPercentage < minInductance ? 'upper' : 'lower'; const idcRange = [Math.min(...idcValues), Math.max(...idcValues)]; resultIdc = solveQuadratic(a, b, c_prime, context, idcRange); } } return resultIdc; }
// --- END: Calculation Logic ---


// --- START: Main Application Logic ---
document.addEventListener('DOMContentLoaded', () => {

    // --- START: Integration & Data Transformation Logic ---
    
    /**
     * UPDATED: This function now scans for the 'L_initial' row and stores its values.
     */
    function parseRawData(text) {
        const blocks = text.trim().split(/\n\s*\n/);
        const allSeries = [];
        const errors = [];
        const metaRegex = /^BLOCK:\s*(.+?)(?:,?\s*N:\s*(\d+))/i;

        blocks.forEach((block, blockIndex) => {
            if (!block.trim()) return;

            const lines = block.trim().split('\n');
            const metaLine = lines[0];
            const match = metaLine.match(metaRegex);

            if (!match) {
                errors.push(`Block ${blockIndex + 1}: Invalid BLOCK format.`);
                return;
            }

            const centerLegName = match[1].trim();
            const nValue = match[2] ? parseInt(match[2], 10) : 0;

            const headerLineIndex = lines.findIndex(l => l.toLowerCase().startsWith('idc(a)'));
            if (headerLineIndex === -1) {
                errors.push(`Block ${blockIndex + 1} (${centerLegName}): Could not find 'Idc(A)' header.`);
                return;
            }
            
            const headers = lines[headerLineIndex].trim().split(/\s+/);
            let idcValues = [];
            let inductanceData = Array.from({ length: headers.length - 1 }, () => []);
            let tableEndIndex = headerLineIndex;

            for (let i = headerLineIndex + 1; i < lines.length; i++) {
                const parts = lines[i].trim().split(/\s+/);
                if (parts.length < headers.length || isNaN(parseFloat(parts[0]))) {
                    tableEndIndex = i;
                    break;
                }
                idcValues.push(parseFloat(parts[0]));
                for (let j = 1; j < headers.length; j++) {
                    inductanceData[j - 1].push(parseFloat(parts[j]));
                }
                tableEndIndex = i + 1;
            }

            // NEW: Look for L_initial row after the main data table
            let lInitialOverrideValues = [];
            const lInitialLine = lines.slice(tableEndIndex).find(l => l.toLowerCase().startsWith('l_initial'));
            if (lInitialLine) {
                lInitialOverrideValues = lInitialLine.trim().split(/\s+/).slice(1).map(parseFloat);
            } else {
                errors.push(`Block ${blockIndex + 1} (${centerLegName}): WARNING - 'L_initial' row not found. Using Idc=0 value.`);
            }
            
            if (idcValues.length < 2) {
                 errors.push(`Block ${blockIndex + 1} (${centerLegName}): Not enough data rows.`);
                 return;
            }

            for (let i = 1; i < headers.length; i++) {
                allSeries.push({
                    centerLegCoreName: centerLegName,
                    nValue: nValue,
                    model: headers[i],
                    idc: idcValues,
                    inductance: inductanceData[i-1],
                    lInitialOverride: lInitialOverrideValues[i-1] // Can be undefined if not found
                });
            }
        });
        
        document.getElementById('processingErrors').innerHTML = errors.join('<br>');
        return allSeries;
    }

    /**
     * UPDATED: This function now uses the L_initial override value for the final data object,
     * while the calculation continues to use the measured Idc=0 value.
     */
    function calculateAndBuildFinalData(series) {
        return series.map(s => {
            // Calculation uses the measured data table (s.inductance) where index 0 is Idc=0
            const idc_70 = findIdcForTarget(s.idc, s.inductance, 70);
            const idc_80 = findIdcForTarget(s.idc, s.inductance, 80);

            // The final L_initial value for display/graphing is the override value.
            // If the override is not found, it falls back to the measured Idc=0 value.
            const final_L_initial = s.lInitialOverride !== undefined && !isNaN(s.lInitialOverride) 
                ? s.lInitialOverride 
                : s.inductance[0];

            return {
                centerLegCore: `${s.centerLegCoreName}_N${s.nValue}`,
                outerCoreShell: s.model,
                L_initial: final_L_initial,
                Idc_70: idc_70,
                Idc_80: idc_80,
                Gap: 0,
                N: s.nValue,
                FoM: idc_80 ? final_L_initial * idc_80 : 0,
            };
        }).filter(d => d.L_initial > 0 && d.Idc_70 !== null && d.Idc_80 !== null);
    }
    
    function formatForAnalysisTool(data) {
        const grouped = data.reduce((acc, item) => {
            if (!acc[item.centerLegCore]) { acc[item.centerLegCore] = []; }
            acc[item.centerLegCore].push(item);
            return acc;
        }, {});

        let output = '';
        for (const groupName in grouped) {
            const items = grouped[groupName];
            const shells = items.map(d => d.outerCoreShell).join('\t');
            const l_initials = items.map(d => d.L_initial.toFixed(2)).join('\t');
            const idc_70s = items.map(d => d.Idc_70.toFixed(2)).join('\t');
            const idc_80s = items.map(d => d.Idc_80.toFixed(2)).join('\t');
            const gaps = items.map(d => d.Gap.toFixed(1)).join('\t');
            const ns = items.map(d => d.N).join('\t');
            
            output += `${groupName}\t${shells}\n`;
            output += `L_initial(uH)\t${l_initials}\n`;
            output += `Idc_70%(A)\t${idc_70s}\n`;
            output += `Idc_80%(A)\t${idc_80s}\n`;
            output += `Gap(mm)\t${gaps}\n`;
            output += `N\t${ns}\n\n`;
        }
        return output;
    }
    
    document.getElementById('processBtn').addEventListener('click', () => {
        const rawText = document.getElementById('rawInput').value;
        if (!rawText.trim()) { alert('Please paste raw data first.'); return; }
        const parsedSeries = parseRawData(rawText);
        if(parsedSeries.length === 0) { alert('Could not parse any valid data. Please check the format and error messages.'); return; }
        const finalData = calculateAndBuildFinalData(parsedSeries);
        if(finalData.length === 0) { alert('Data was parsed, but calculations failed for all entries. Check if Idc=0 data is present.'); return; }
        const formattedText = formatForAnalysisTool(finalData);
        document.getElementById('dataInput').value = formattedText;
        document.getElementById('analysisContainer').classList.remove('hidden');
        app.updateAll();
    });

    // --- END: Integration Logic ---


    // --- START: Analysis App Logic (No changes needed below this line) ---
    const app = {
        elements: {}, chartInstance: null, parsedData: [],
        defaultColors: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
        pointStyles: ['circle', 'rect', 'triangle', 'rectRot', 'star', 'cross', 'rectRounded'],
        init() { this.cacheElements(); this.addEventListeners(); },
        cacheElements() { const ids = [ 'dataInput', 'xAxis', 'yAxis', 'centerLegFilterControls', 'outerCoreFilterControls', 'mainChart', 'statsTableBody', 'dataCount', 'chartStatus', 'btnExportCSV', 'btnExportPNG', 'parsedDataTableBody', 'selectAllCenterLegs', 'deselectAllCenterLegs', 'selectAllOuterCores', 'deselectAllOuterCores' ]; ids.forEach(id => this.elements[id] = document.getElementById(id)); },
        addEventListeners() { const controlsToRedrawChart = ['xAxis', 'yAxis', 'centerLegFilterControls', 'outerCoreFilterControls']; controlsToRedrawChart.forEach(id => this.elements[id].addEventListener('change', () => this.updateUI())); this.elements.btnExportCSV.addEventListener('click', () => this.exportCSV()); this.elements.btnExportPNG.addEventListener('click', () => this.exportPNG()); this.elements.selectAllCenterLegs.addEventListener('click', () => { this.setAllCheckboxes(this.elements.centerLegFilterControls, true); this.updateUI(); }); this.elements.deselectAllCenterLegs.addEventListener('click', () => { this.setAllCheckboxes(this.elements.centerLegFilterControls, false); this.updateUI(); }); this.elements.selectAllOuterCores.addEventListener('click', () => { this.setAllCheckboxes(this.elements.outerCoreFilterControls, true); this.updateUI(); }); this.elements.deselectAllOuterCores.addEventListener('click', () => { this.setAllCheckboxes(this.elements.outerCoreFilterControls, false); this.updateUI(); }); },
        setAllCheckboxes(container, isChecked) { container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = isChecked); },
        parseData() { const lines = this.elements.dataInput.value.trim().split('\n'); const result = []; let currentBlock = this.createEmptyBlock(); const flushBlock = () => { if (!currentBlock.centerLegCore) return; const { centerLegCore, outerCoreShells, lValues, idc70Values, idc80Values, gapValues, nValues } = currentBlock; const n = Math.min(outerCoreShells.length, lValues.length, idc70Values.length, idc80Values.length, gapValues.length, nValues.length); for (let i = 0; i < n; i++) { const L = lValues[i], I70 = idc70Values[i], I80 = idc80Values[i], G = gapValues[i], N = nValues[i]; if ([L, I70, I80, G, N].some(v => v === undefined || isNaN(v))) continue; result.push({ centerLegCore: centerLegCore, outerCoreShell: String(outerCoreShells[i]), L_initial: L, Idc_70: I70, Idc_80: I80, Gap: G, N: N, FoM: L * I80, }); } currentBlock = this.createEmptyBlock(); }; for (const line of lines) { const trimmedLine = line.trim(); if (!trimmedLine) continue; const parts = trimmedLine.split(/\s+/); const label = parts[0].toLowerCase(); if (label.startsWith('clc_')) { flushBlock(); currentBlock.centerLegCore = parts[0]; currentBlock.outerCoreShells = parts.slice(1); } else if (label.startsWith('l_initial')) { currentBlock.lValues = parts.slice(1).map(parseFloat); } else if (label.startsWith('idc_70%')) { currentBlock.idc70Values = parts.slice(1).map(parseFloat); } else if (label.startsWith('idc_80%')) { currentBlock.idc80Values = parts.slice(1).map(parseFloat); } else if (label.startsWith('gap(mm)')) { currentBlock.gapValues = parts.slice(1).map(parseFloat); } else if (label.startsWith('n')) { currentBlock.nValues = parts.slice(1).map(parseFloat); } } flushBlock(); return result; },
        createEmptyBlock: () => ({ centerLegCore: null, outerCoreShells: [], lValues: [], idc70Values: [], idc80Values: [], gapValues: [], nValues: [] }),
        getFilteredData() { const selectedCenterLegs = new Set(Array.from(this.elements.centerLegFilterControls.querySelectorAll('input:checked')).map(chk => chk.dataset.value)); const selectedOuterShells = new Set(Array.from(this.elements.outerCoreFilterControls.querySelectorAll('input:checked')).map(chk => chk.dataset.value)); if (selectedCenterLegs.size === 0 || selectedOuterShells.size === 0) return []; return this.parsedData.filter(d => selectedCenterLegs.has(d.centerLegCore) && selectedOuterShells.has(d.outerCoreShell)); },
        groupData: (data, groupBy) => data.reduce((groups, item) => { const key = item[groupBy]; if (!groups[key]) groups[key] = []; groups[key].push(item); return groups; }, {}),
        updateAll() { this.parsedData = this.parseData(); const allCenterLegs = [...new Set(this.parsedData.map(d => d.centerLegCore))].sort(); const allOuterShells = [...new Set(this.parsedData.map(d => d.outerCoreShell))].sort((a, b) => a - b); this.updateFilterControls(this.elements.centerLegFilterControls, allCenterLegs, true); this.updateFilterControls(this.elements.outerCoreFilterControls, allOuterShells, true); this.updateParsedDataTable(); this.updateUI(); },
        updateUI() { const baseData = this.getFilteredData(); const groupedData = this.groupData(baseData, 'centerLegCore'); this.updateStatsTable(groupedData); this.createChart(); },
        updateParsedDataTable() { const { parsedDataTableBody, dataCount } = this.elements; parsedDataTableBody.innerHTML = ''; dataCount.textContent = `Total of ${this.parsedData.length} data points recognized`; if (this.parsedData.length === 0) { parsedDataTableBody.innerHTML = `<tr><td colspan="8">No data recognized.</td></tr>`; return; } let rows = ''; this.parsedData.forEach(d => { rows += `<tr><td>${d.centerLegCore}</td><td>${d.outerCoreShell}</td><td>${d.L_initial.toFixed(2)}</td><td>${d.Idc_70.toFixed(2)}</td><td>${d.Idc_80.toFixed(2)}</td><td>${d.Gap.toFixed(2)}</td><td>${d.N}</td><td>${d.FoM.toFixed(1)}</td></tr>`; }); parsedDataTableBody.innerHTML = rows; },
        updateFilterControls(container, values, checkAll = false) { const checkedState = new Map(); container.querySelectorAll('input[type="checkbox"]').forEach(chk => { checkedState.set(chk.dataset.value, chk.checked); }); container.innerHTML = ''; if (!values || values.length === 0) return; values.forEach(value => { const isChecked = checkAll ? 'checked' : (checkedState.has(value) ? (checkedState.get(value) ? 'checked' : '') : 'checked'); container.innerHTML += `<div class="filter-item"><input type="checkbox" id="chk-${container.id}-${value}" data-value="${value}" ${isChecked}><label for="chk-${container.id}-${value}">${value}</label></div>`; }); },
        updateStatsTable(groupedData) { const { statsTableBody } = this.elements; statsTableBody.innerHTML = ''; if (Object.keys(groupedData).length === 0) { statsTableBody.innerHTML = '<tr><td colspan="7">No data selected. Check filters.</td></tr>'; return; } for (const group in groupedData) { const items = groupedData[group]; const calcStats = (arr) => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0; statsTableBody.innerHTML += `<tr><td><strong>${group}</strong></td><td>${items.length}</td><td>${calcStats(items.map(d => d.L_initial)).toFixed(2)}</td><td>${calcStats(items.map(d => d.Idc_70)).toFixed(2)}</td><td>${calcStats(items.map(d => d.Idc_80)).toFixed(2)}</td><td>${calcStats(items.map(d => d.FoM)).toFixed(1)}</td><td>${calcStats(items.map(d => d.Gap)).toFixed(2)}</td></tr>`; } },
        showStatus(msg, isError = false) { const { chartStatus } = this.elements; chartStatus.textContent = msg; chartStatus.style.display = 'block'; chartStatus.style.background = isError ? 'rgba(200, 0, 0, 0.7)' : 'rgba(0, 0, 0, 0.7)'; },
        
        // ==================================================================
        // ===== ✨ MODIFIED SECTION START ✨ =====
        // ==================================================================
        createChart() {
            const baseData = this.getFilteredData();
            const groupedData = this.groupData(baseData, 'centerLegCore');
            const allCenterLegs = [...new Set(this.parsedData.map(d => d.centerLegCore))].sort();
            
            if (this.chartInstance) {
                this.chartInstance.destroy();
            }

            // 클릭으로 생성된 주석(레이블)을 저장할 배열을 초기화합니다.
            this.chartAnnotations = [];

            const ctx = this.elements.mainChart.getContext('2d');
            ctx.clearRect(0, 0, this.elements.mainChart.width, this.elements.mainChart.height);
            
            if (!baseData.length) {
                this.showStatus('No data to display.', true);
                return;
            }
            this.showStatus('Generating chart...');

            const { xAxis, yAxis } = this.elements;

            // 툴팁과 클릭 레이블에 사용될 텍스트를 생성하는 헬퍼 함수입니다.
            const getLabelText = (item) => {
                if (!item) return '';
                return [
                    `${item.centerLegCore} / Shell ${item.outerCoreShell}`,
                    `L=${item.L_initial.toFixed(1)} μH`,
                    `Idc_70=${item.Idc_70.toFixed(1)} A, Idc_80=${item.Idc_80.toFixed(1)} A`,
                    `Gap=${item.Gap.toFixed(1)} mm, N=${item.N}`,
                    `FoM=${item.FoM.toFixed(1)}`
                ];
            };

            const datasets = Object.keys(groupedData).map(group => {
                const coreIndex = allCenterLegs.indexOf(group);
                const color = this.defaultColors[coreIndex % this.defaultColors.length];
                const pointStyle = this.pointStyles[coreIndex % this.pointStyles.length];
                const data = groupedData[group].map(item => ({
                    x: item[xAxis.value],
                    y: item[yAxis.value],
                    raw: item
                }));
                return {
                    label: group,
                    data,
                    backgroundColor: color,
                    borderColor: color,
                    pointStyle: pointStyle,
                    radius: 6,
                    hoverRadius: 9
                };
            });

            // --- NEW: 클릭된 레이블을 그리기 위한 커스텀 플러그인 ---
            const annotationPlugin = {
                id: 'clickAnnotations',
                afterDraw: (chart) => {
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'bottom';

                    this.chartAnnotations.forEach(annotation => {
                        const model = chart.getDatasetMeta(annotation.datasetIndex).data[annotation.index];
                        if (!model) return;

                        const x = model.x + 10; // 점 옆에 약간의 간격을 둡니다.
                        const y = model.y;
                        const textLines = annotation.text;
                        const lineHeight = 14;
                        const textWidth = Math.max(...textLines.map(line => ctx.measureText(line).width));
                        
                        // 텍스트 뒤에 배경 상자를 그려 가독성을 높입니다.
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                        ctx.fillRect(x - 3, y - (lineHeight * textLines.length) - 3, textWidth + 6, (lineHeight * textLines.length) + 6);
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x - 3, y - (lineHeight * textLines.length) - 3, textWidth + 6, (lineHeight * textLines.length) + 6);

                        // 여러 줄의 텍스트를 그립니다.
                        ctx.fillStyle = '#333';
                        textLines.forEach((line, i) => {
                            ctx.fillText(line, x, y - (lineHeight * (textLines.length - 1 - i)));
                        });
                    });
                    ctx.restore();
                }
            };

            this.chartInstance = new Chart(this.elements.mainChart, {
                type: 'scatter',
                data: { datasets },
                plugins: [annotationPlugin], // 커스텀 플러그인을 등록합니다.
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    // --- NEW: onClick 이벤트 핸들러 ---
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const { datasetIndex, index } = elements[0];
                            const item = this.chartInstance.data.datasets[datasetIndex].data[index].raw;

                            // 이 점에 대한 레이블이 이미 있는지 확인합니다.
                            const existingAnnotationIndex = this.chartAnnotations.findIndex(
                                a => a.datasetIndex === datasetIndex && a.index === index
                            );

                            if (existingAnnotationIndex > -1) {
                                // 이미 있다면 제거합니다 (토글 기능).
                                this.chartAnnotations.splice(existingAnnotationIndex, 1);
                            } else {
                                // 없다면 새로 추가합니다.
                                this.chartAnnotations.push({
                                    datasetIndex,
                                    index,
                                    text: getLabelText(item)
                                });
                            }
                            // 차트를 다시 그려서 변경사항을 반영합니다.
                            this.chartInstance.update('none'); // 'none'은 애니메이션 없이 업데이트합니다.
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: { usePointStyle: true, padding: 20 }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const item = context.raw?.raw;
                                    return getLabelText(item);
                                }
                            }
                        }
                    },
                    scales: {
                        x: { title: { display: true, text: xAxis.options[xAxis.selectedIndex].text } },
                        y: { title: { display: true, text: yAxis.options[yAxis.selectedIndex].text } }
                    }
                }
            });
            setTimeout(() => this.elements.chartStatus.style.display = 'none', 1000);
        },
        // ==================================================================
        // ===== ✨ MODIFIED SECTION END ✨ =====
        // ==================================================================
        exportCSV() { const data = this.getFilteredData(); if (data.length === 0) { alert('No data selected to export.'); return; } const headers = "CenterLegCore,OuterCoreShell,L_initial(uH),Idc_70%(A),Idc_80%(A),Gap(mm),N,FoM"; const rows = data.map(d => `${d.centerLegCore},${d.outerCoreShell},${d.L_initial},${d.Idc_70},${d.Idc_80},${d.Gap},${d.N},${d.FoM.toFixed(2)}`); const csvContent = "data:text/csv;charset=utf-8," + [headers, ...rows].join("\n"); const encodedUri = encodeURI(csvContent); const link = document.createElement("a"); link.setAttribute("href", encodedUri); link.setAttribute("download", "inductance_data_export.csv"); document.body.appendChild(link); link.click(); document.body.removeChild(link); },
        exportPNG() { if (!this.chartInstance || !this.getFilteredData().length) { alert('No chart available to export.'); return; } const url = this.chartInstance.toBase64Image(); const link = document.createElement('a'); link.download = 'inductance_chart.png'; link.href = url; link.click(); }
    };
    app.init();
    // --- END: Analysis App Logic ---
});
</script>
</body>
</html>
