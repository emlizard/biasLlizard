<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Integrated Inductance Analysis Tool (L_initial Logic)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family: 'Arial', sans-serif; background:#f5f5f5; padding:20px; }
        .container { max-width:1000px; margin:0 auto; background:#fff; border-radius:10px; padding:30px; box-shadow:0 2px 10px rgba(0,0,0,.1); }
        .title { font-size:28px; font-weight:700; color:#333; margin-bottom:30px; text-align:center; }
        .section { margin-bottom:30px; }
        .section-title { font-size:20px; font-weight:700; color:#444; margin-bottom:15px; border-bottom:2px solid #007bff; padding-bottom:5px; }
        .data-input { width:100%; height:250px; padding:15px; border:2px solid #ddd; border-radius:8px; font-family:'Courier New', monospace; font-size:12px; resize:vertical; }
        .controls { display:grid; grid-template-columns:repeat(auto-fit, minmax(200px,1fr)); gap:20px; background:#f8f9fa; padding:20px; border-radius:8px; }
        .control-group { display:flex; flex-direction:column; }
        .control-group label { font-weight:700; margin-bottom:6px; color:#555; }
        .control-group select { padding:8px; border:1px solid #ccc; border-radius:5px; font-size:14px; }
        .chart-container { position:relative; height:500px; margin:20px 0; background:#fff; border:1px solid #ddd; border-radius:8px; padding:20px; }
        #chartStatus { position:absolute; top:10px; right:10px; background:rgba(0,0,0,.7); color:#fff; padding:5px 10px; border-radius:5px; font-size:14px; display:none; }
        .table-wrapper { max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; margin-top: 15px; }
        .stats-table { width:100%; border-collapse:collapse; background:#fff; font-size:13px; }
        .stats-table th, .stats-table td { padding:8px; text-align:center; border-bottom:1px solid #eee; }
        .stats-table th { background:#007bff; color:#fff; font-weight:700; font-size:11px; position: sticky; top: 0; z-index: 1; }
        .stats-table tr:nth-child(even){ background:#f8f9fa; }
        .stats-table tr:hover{ background:#e3f2fd; }
        .data-count { background:#28a745; color:#fff; padding:5px 10px; border-radius:15px; font-size:12px; margin-top:10px; display:inline-block; }
        .btn { background:#007bff; color:#fff; border:none; padding:12px 25px; border-radius:8px; cursor:pointer; font-size:16px; margin:5px; transition: background-color 0.3s ease; }
        .btn:hover{ background:#0056b3; }
        .btn-secondary{ background:#6c757d; }
        .btn-secondary:hover{ background:#545b62; }
        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; background-color: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #ddd; max-height: 200px; overflow-y: auto; }
        .filter-item { display: flex; align-items: center; background: #fff; padding: 8px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-size: 13px; }
        .filter-item input { margin-right: 10px; }
        .filter-item label { display: flex; align-items: center; cursor: pointer; flex: 1; }
        .filter-actions { margin-bottom: 10px; }
        .btn-filter { background: #6c757d; color: white; border: none; padding: 5px 10px; font-size: 12px; border-radius: 4px; cursor: pointer; margin-right: 5px; }
        .btn-filter:hover { background: #5a6268; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">🚀 Integrated Inductance Analysis Tool (L_initial Logic)</h1>
        
        <div class="section">
            <h2 class="section-title">Step 1: Paste Raw Data</h2>
            <textarea id="rawInput" class="data-input" placeholder="이곳에 데이터를 붙여넣으세요.
L_initial 행을 포함해야 합니다.

BLOCK: CLC_6x15x5R2, N: 27												
Idc(A)	104	105	106	107	108							
0	53.6	54	50.9	53.8	55.4							
10	50.5	50.9	49.1	52	53.2							
15	47.7	46.7	45.6	48	49							
19	45.4	43.3	42.9	44.7	45.5							
L_initial	54.1	54.5	51.6	54.1	56.1							
												
BLOCK: CLC_6x15x5.5R2, N: 27												
Idc(A)	104	105	106	107	108							
0	60	60.3	56.8	58.9	62.2							
10	55.8	54.4	52.4	55.1	57							
15	51.1	49.4	48	50.7	51.7							
19	47.1	45.5	44.6	46.9	47.6							
L_initial	60.6	61.4	57.1	60	62.7							
												
BLOCK: CLC_6x15x5R2, N: 30												
Idc(A)	104	105	106	107	108							
0	68.8	69.4	64.9	69.1	70.2							
10	63.4	62.2	60.7	63.3	64.2							
15	58.7	56.8	55.5	58.4	59.3							
19	55.2	52.9	51.5	54.5	55.4							
L_initial	69.4	70	65.8	69.8	71							
												
BLOCK: CLC_6x15x5.5R2, N: 30												
Idc(A)	104	105	106	107	108							
0	76.6	78.2	72.8	76.6	79							
10	68.6	67.3	64.9	68.7	70.2							
15	61.8	59.7	58.4	61.6	62.5							
19	56	54.4	53.5	55.6	56.1							
L_initial	77.4	79.4	73.6	77.8	80							
												
BLOCK: CLC_6x15x5R2, N: 31												
Idc(A)	104	105	106	107	108							
0	74.3	74.5	69.3	74.1	76.2							
10	68	66.4	64.7	67.4	69.2							
15	62.7	60.3	58.9	61.8	53.3							
19	58.6	55.9	54.7	57.5	58.9							
L_initial	75.2	75.4	71	75	77.2							
												
BLOCK: CLC_6x15x5.5R2, N: 31												
Idc(A)	104	105	106	107	108							
0	82.1	83.6	76.8	82.1	84.6							
10	73.2	71.6	68.8	73.3	74.9							
15	66	62.8	61.4	64.8	65.9							
19	60.6	56.9	56.1	57.9	58.8							
L_initial	83.4	84.8	78.5	83.2	86.5							
												
BLOCK: CLC_8x15x5.5R2, N: 24												
Idc(A)	104	105	106	107	108							
0	55.7	57.2	52.7	55.8	57.6							
10	51.1	50.4	48.2	51.3	52.5							
15	47	45.3	44	46.7	47.6							
19	43.8	41.7	40.8	43.2	43.8							
L_initial	56.1	57.4	53.2	56.2	58.1							
												
BLOCK: CLC_8x15x5.5R2, N: 29												
Idc(A)	104	105	106	107	108							
0	75.4	77.1	70.5	75.6	78.3							
10	67.9	65.9	63.2	67.4	69.1							
15	60.7	58	56.6	59.7	61.1							
19	55.5	52.8	51.9	54.7	55.3							
L_initial	76.3	77.9	72.3	76.2	79.6							
												
BLOCK: CLC_8x15x5.5R2, N: 30												
Idc(A)	104	105	106	107	108							
0	80.5	81.9	76.6	80.5	84.4							
10	71.4	69.7	67.4	71.6	73.3							
15	64.2	61.3	60	63.5	64.7							
19	59.1	55.8	54.8	57.7	58.7							
L_initial	81.6	83.7	77.3	82.2	85.3							
												
BLOCK: CLC_6x15x2.5R2, N: 31												
Idc(A)	100	101	102	103								
0	76.1	83.2	77.4	74								
10	68.8	75.1	72.4	66.9								
15	62.7	68.7	64.4	61.4								
17	60.5	66.4	61.7	59.5								
19	57	60	54	53								
L_initial	77.4	84.2	78.8	74.7								
												
BLOCK: CLC_6x15x3R2, N: 31												
Idc(A)	100	101	102	103								
0	80.2	90	84.6	79								
10	71.5	80.2	75.5	70.6								
15	64.5	72.3	66.9	64.2								
17	62	69.4	63.7	61.9								
19	55.4	64	55.1	57								
L_initial	81.2	92.7	85.5	80.1								
												
BLOCK: CLC_No, N: 31												
Idc(A)	100	101	102	103								
0	63.2	68	64.8	62.7								
10	59	63.9	60.3	58.5								
15	55.7	60.5	56.8	55.1								
17	54.4	59.3	55.4	54								
19	51	54	50	49								
L_initial	64.5	69.2	66	63.7								
												
BLOCK: 6x15x3R2, N: 30												
Idc(A)	114											
0	106.6											
10	94											
15	85.6											
19	79											
L_initial	108.7											
												
BLOCK: CLC_8x15x2.5R2, N: 29												
Idc(A)	109	110	111	112	114	116	117	118	121	122	123	124
0	72.8	79.3	66	67.3	97.2	98.8	97.8	96	75.7	64.1	74.7	63.6
10	65.1	71.9	61.5	62.6	86.9	86.1	86.6	84.6	70.3	36.8	46.9	37.6
15	59.5	66.8	58	59.7	80.1	76.7	79.4	77.1	65.9	32.1	39.9	32.6
19	55.7	63.4	55.4	55.9	75.3	69.3	74.2	71.5	61.3	30.1	36.3	30.4
L_initial	73.6	80.3	66.7	68.7	98.7	100.3	99.4	97.5	76.2	64.7	75.6	64.1
												
BLOCK: CLC_8x15x2.9, N: 29												
Idc(A)	109	110	111	112	114	116	117	118				
0	77.6	87.5	70.9	71.4	108.2	108.4	106.7	105.3				
10	69.7	77.4	65.4	65.7	94	91.9	93.2	91				
15	62	70.7	61	61	84.4	79.8	83.7	81.2				
19	56.8	66.1	57.5	57.5	77.1	70.2	76	73.8				
L_initial	78.6	88.6	72.3	72.9	110	110.4	108.6	107				
												
BLOCK: CLC_No, N: 29												
Idc(A)	109	110	111	112	113	114	116	117	118			
0	57.9	62.8	53.4	54.8	39.1	69.9	70.9	70.4	69.2			
10	54.1	59.2	51.5	52.2	37.1	66.1	66.2	66.4	64.9			
15	51	56.4	49.7	50.2	35.3	63.4	62.7	63.4	61.8			
19	48.7	54.5	48.2	48.6	33.9	61.6	59.9	61.3	59.7			
L_initial	58.4	63.5	54.2	55.6	39.4	70.6	71.7	71.3	70.1			
												
BLOCK: CLC_8x15x2.5R2, N:30(wide)												
Idc(A)	111	112	121									
0	90.1	93.1	90.7									
10	81.2	82.6	83.2									
15	74.2	74.8	77.4									
19	64	65	67									
L_initial	92.4	95.4	92									
												
BLOCK: CLC_No, N: 30												
Idc(A)	111	112										
0	77.1	80.3										
10	71.3	72.9										
15	66.5	66.8										
19	60	58										
L_initial	79.1	81.4										
												
BLOCK: CLC_10x15x3R2, N: 24												
Idc(A)	110	114	116	117	118							
0	65	84.5	85.7	84	82.5							
10	61	77.9	74.3	74.8	72.8							
15	56.1	69.8	65.8	68.4	66.1							
19	52.7	65.1	58.9	63.6	61.1							
L_initial	65.5	85.8	87.1	85.1	83.8							
												
BLOCK: CLC_10x15x2.5, N: 24												
Idc(A)	110	114	116	117	118							
0	59.8	74.9	75.5	74.4	73.3							
10	57.8	69.1	68.1	68.2	66.7							
15	53.4	64.6	62.1	63.6	61.8							
19	50.2	61.1	57	59.9	57.9							
L_initial	60.3	75.8	76.3	75.3	74.1							
												
BLOCK: CLC_No, N: 24												
Idc(A)	110	114	116	117	118							
0	46.1	53.2	53.4	52.9	52.1							
10	44.1	50.9	50.7	50.5	49.6							
15	42.5	49.2	48.6	48.7	47.7							
19	41.2	47.9	46.9	47.4	46.2							
L_initial	46.4	53.6	54	53.4	52.6							
												
BLOCK: CLC_NCR50p_8x15x4, N: 29												
Idc(A)	114											
0	93.1											
10	84.3											
15	78.3											
19	74.2											
L_initial	94.6											
												
BLOCK: CLC_6x15x2.5R2, N: 28												
Idc(A)	110	114	116	117	118	103						
0	61.3	76.1	76.4	75.8	74.7	56.8						
10	57.4	70.8	72.4	70	68.7	53.1						
15	54.5	66.8	62.6	65.8	64.3	50						
19	52.4	63.8	56.2	62.6	61	47.5						
L_initial	61.8	77.2	77.6	76.7	75.9	57.3						
												
BLOCK: CLC_6x15x3R2, N: 28												
Idc(A)	110	114	116	117	118	121	122	123	124			
0	67.6	87.2	87.1	85.9	84.5	66.7	55.7	65.4	55.8			
10	62	78.3	77	77	75.8	62.4	32.6	41.5	33.5			
15	58.1	72.4	69.2	70.9	69.4	59	28.5	35.6	28.9			
19	55.4	67.9	62.8	66.4	64.6	54.6	26.5	32.5	26.8			
L_initial	68	88.2	88.6	87.2	86.3	67.4	56.5	66.1	56.7			

"></textarea>
            <div style="text-align: center; margin-top: 20px;">
                <button id="processBtn" class="btn">📊 Process and Analyze Data</button>
            </div>
             <div id="processingErrors" style="margin-top:15px; font-size:13px; color:#c00; font-family:'Courier New', monospace;"></div>
        </div>

        <textarea id="dataInput" class="data-input hidden"></textarea>

        <div id="analysisContainer" class="hidden">
            <hr style="margin: 40px 0;">
            <h2 class="section-title" style="text-align: center; font-size: 24px; border-bottom: none;">Step 2: Analysis Results</h2>
            <div class="section">
                <h2 class="section-title">Parsed Data Confirmation</h2>
                <div id="dataCount" class="data-count">Waiting for data...</div>
                <div class="table-wrapper">
                    <table class="stats-table" id="parsedDataTable">
                        <thead>
                            <tr>
                                <th>Center Leg</th><th>Outer Shell</th><th>L_initial(uH)</th><th>Idc_70%(A)</th><th>Idc_80%(A)</th><th>Gap(mm)</th><th>N</th><th>FoM</th>
                            </tr>
                        </thead>
                        <tbody id="parsedDataTableBody"></tbody>
                    </table>
                </div>
            </div>
            <div class="section">
                <h2 class="section-title">Center Leg Core Filter</h2>
                <div class="filter-actions">
                    <button class="btn-filter" id="selectAllCenterLegs">Select All</button>
                    <button class="btn-filter" id="deselectAllCenterLegs">Deselect All</button>
                </div>
                <div class="filter-controls" id="centerLegFilterControls"></div>
            </div>
            <div class="section">
                <h2 class="section-title">Outer Core Shell Filter</h2>
                <div class="filter-actions">
                    <button class="btn-filter" id="selectAllOuterCores">Select All</button>
                    <button class="btn-filter" id="deselectAllOuterCores">Deselect All</button>
                </div>
                <div class="filter-controls" id="outerCoreFilterControls"></div>
            </div>
            <div class="section">
                <h2 class="section-title">Analysis Options</h2>
                <div class="controls">
                    <div class="control-group"><label for="xAxis">X-Axis</label><select id="xAxis"><option value="Idc_80">Idc 80% (A)</option><option value="Idc_70">Idc 70% (A)</option><option value="L_initial">Inductance (μH)</option><option value="FoM">FoM (L×Idc)</option><option value="Gap">Gap (mm)</option></select></div>
                    <div class="control-group"><label for="yAxis">Y-Axis</label><select id="yAxis"><option value="L_initial">Inductance (μH)</option><option value="Idc_80">Idc 80% (A)</option><option value="Idc_70">Idc 70% (A)</option><option value="FoM">FoM (L×Idc)</option><option value="Gap">Gap (mm)</option></select></div>
                    <div class="control-group"><label>&nbsp;</label><button class="btn btn-secondary" id="btnExportCSV">Export Selected Data to CSV</button></div>
                    <div class="control-group"><label>&nbsp;</label><button class="btn btn-secondary" id="btnExportPNG">Export Chart to PNG</button></div>
                </div>
            </div>
            <div class="section">
                <h2 class="section-title">Analysis Chart</h2>
                <div class="chart-container"><canvas id="mainChart"></canvas><div id="chartStatus">Loading...</div></div>
            </div>
            <div class="section">
                <h2 class="section-title">Statistics Summary (Based on selected data)</h2>
                <div class="table-wrapper" style="max-height: none;">
                    <table class="stats-table" id="statsTable">
                        <thead><tr><th>Group (Center Leg)</th><th>Count</th><th>L Avg (μH)</th><th>Idc_70% Avg (A)</th><th>Idc_80% Avg (A)</th><th>FoM Avg</th><th>Gap Avg (mm)</th></tr></thead>
                        <tbody id="statsTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

<script>
// --- START: Calculation Logic (Interpolation/Extrapolation) ---
class CubicSpline {
    constructor(x, y) { this.x = [...x]; this.y = [...y]; this.n = x.length; this.calculateCoefficients(); }
    calculateCoefficients() { const n = this.n; const h = new Array(n - 1); for (let i = 0; i < n - 1; i++) h[i] = this.x[i + 1] - this.x[i]; const alpha = new Array(n - 1); for (let i = 1; i < n - 1; i++) alpha[i] = (3 / h[i]) * (this.y[i + 1] - this.y[i]) - (3 / h[i - 1]) * (this.y[i] - this.y[i - 1]); const l = new Array(n); const mu = new Array(n); const z = new Array(n); l[0] = 1; mu[0] = 0; z[0] = 0; for (let i = 1; i < n - 1; i++) { l[i] = 2 * (this.x[i + 1] - this.x[i - 1]) - h[i - 1] * mu[i - 1]; mu[i] = h[i] / l[i]; z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i]; } l[n - 1] = 1; z[n - 1] = 0; this.c = new Array(n); this.b = new Array(n - 1); this.d = new Array(n - 1); this.c[n - 1] = 0; for (let j = n - 2; j >= 0; j--) { this.c[j] = z[j] - mu[j] * this.c[j + 1]; this.b[j] = (this.y[j + 1] - this.y[j]) / h[j] - h[j] * (this.c[j + 1] + 2 * this.c[j]) / 3; this.d[j] = (this.c[j + 1] - this.c[j]) / (3 * h[j]); } }
    interpolate(x) { if (x < this.x[0] || x > this.x[this.n-1]) return null; let i = 0; for (i = 0; i < this.n - 1; i++) if (x <= this.x[i + 1]) break; const dx = x - this.x[i]; return this.y[i] + this.b[i] * dx + this.c[i] * dx * dx + this.d[i] * dx * dx * dx; }
    findX(targetY, tolerance = 0.001) { let left = this.x[0], right = this.x[this.n - 1]; let iterations = 0; const maxIterations = 200; while (right - left > tolerance && iterations < maxIterations) { const mid = (left + right) / 2; const midY = this.interpolate(mid); if (midY === null) return { value: null }; if (midY > targetY) left = mid; else right = mid; iterations++; } const finalValue = (left + right) / 2; return { value: finalValue, isExtrapolated: false }; }
}
function polynomialRegression(x, y) { const n = x.length; let sumX = 0, sumY = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0, sumXY = 0, sumX2Y = 0; for (let i = 0; i < n; i++) { sumX += x[i]; sumY += y[i]; sumX2 += x[i] * x[i]; sumX3 += x[i] * x[i] * x[i]; sumX4 += x[i] * x[i] * x[i] * x[i]; sumXY += x[i] * y[i]; sumX2Y += x[i] * x[i] * y[i]; } const SXX = sumX2 - sumX * sumX / n; const SXY = sumXY - sumX * sumY / n; const SXX2 = sumX3 - sumX * sumX2 / n; const SX2Y = sumX2Y - sumX2 * sumY / n; const SX2X2 = sumX4 - sumX2 * sumX2 / n; const denominator = (SX2X2 * SXX - SXX2 * SXX2); if (Math.abs(denominator) < 1e-10) return null; const a = (SX2Y * SXX - SXY * SXX2) / denominator; const b = (SXY * SX2X2 - SX2Y * SXX2) / denominator; const c = sumY / n - b * sumX / n - a * sumX2 / n; const yMean = sumY / n; let sst = 0, sse = 0; for (let i = 0; i < n; i++) { sst += (y[i] - yMean) * (y[i] - yMean); const predictedY = a * x[i] * x[i] + b * x[i] + c; sse += (y[i] - predictedY) * (y[i] - predictedY); } const r2 = 1 - (sse / sst); return { coefficients: [a, b, c], r2 }; }
function solveQuadratic(a, b, c, context, range) { const discriminant = b * b - 4 * a * c; if (discriminant < 0) return null; const root1 = (-b + Math.sqrt(discriminant)) / (2 * a); const root2 = (-b - Math.sqrt(discriminant)) / (2 * a); if (context === 'upper') { return root1 > range[1] ? root1 : (root2 > range[1] ? root2 : null); } if (context === 'lower') { return root1 < range[0] ? root1 : (root2 < range[0] ? root2 : null); } return null; }
function findIdcForTarget(idcValues, inductanceValues, targetPercentage) { const initialInductance = inductanceValues[0]; if (initialInductance === 0) return null; const normalizedInductance = inductanceValues.map(val => (val / initialInductance) * 100); const minInductance = Math.min(...normalizedInductance); const maxInductance = Math.max(...normalizedInductance); let resultIdc = null; if (targetPercentage >= minInductance && targetPercentage <= maxInductance) { const spline = new CubicSpline(idcValues, normalizedInductance); const splineResult = spline.findX(targetPercentage); resultIdc = splineResult.value; } else { const regression = polynomialRegression(idcValues, normalizedInductance); if (regression && regression.r2 >= 0.95) { const [a, b, c] = regression.coefficients; const c_prime = c - targetPercentage; const context = targetPercentage < minInductance ? 'upper' : 'lower'; const idcRange = [Math.min(...idcValues), Math.max(...idcValues)]; resultIdc = solveQuadratic(a, b, c_prime, context, idcRange); } } return resultIdc; }
// --- END: Calculation Logic ---


// --- START: Main Application Logic ---
document.addEventListener('DOMContentLoaded', () => {

    // --- START: Integration & Data Transformation Logic ---
    
    /**
     * UPDATED: This function now scans for the 'L_initial' row and stores its values.
     */
    function parseRawData(text) {
        const blocks = text.trim().split(/\n\s*\n/);
        const allSeries = [];
        const errors = [];
        const metaRegex = /^BLOCK:\s*(.+?)(?:,?\s*N:\s*(\d+))/i;

        blocks.forEach((block, blockIndex) => {
            if (!block.trim()) return;

            const lines = block.trim().split('\n');
            const metaLine = lines[0];
            const match = metaLine.match(metaRegex);

            if (!match) {
                errors.push(`Block ${blockIndex + 1}: Invalid BLOCK format.`);
                return;
            }

            const centerLegName = match[1].trim();
            const nValue = match[2] ? parseInt(match[2], 10) : 0;

            const headerLineIndex = lines.findIndex(l => l.toLowerCase().startsWith('idc(a)'));
            if (headerLineIndex === -1) {
                errors.push(`Block ${blockIndex + 1} (${centerLegName}): Could not find 'Idc(A)' header.`);
                return;
            }
            
            const headers = lines[headerLineIndex].trim().split(/\s+/);
            let idcValues = [];
            let inductanceData = Array.from({ length: headers.length - 1 }, () => []);
            let tableEndIndex = headerLineIndex;

            for (let i = headerLineIndex + 1; i < lines.length; i++) {
                const parts = lines[i].trim().split(/\s+/);
                if (parts.length < headers.length || isNaN(parseFloat(parts[0]))) {
                    tableEndIndex = i;
                    break;
                }
                idcValues.push(parseFloat(parts[0]));
                for (let j = 1; j < headers.length; j++) {
                    inductanceData[j - 1].push(parseFloat(parts[j]));
                }
                tableEndIndex = i + 1;
            }

            // NEW: Look for L_initial row after the main data table
            let lInitialOverrideValues = [];
            const lInitialLine = lines.slice(tableEndIndex).find(l => l.toLowerCase().startsWith('l_initial'));
            if (lInitialLine) {
                lInitialOverrideValues = lInitialLine.trim().split(/\s+/).slice(1).map(parseFloat);
            } else {
                errors.push(`Block ${blockIndex + 1} (${centerLegName}): WARNING - 'L_initial' row not found. Using Idc=0 value.`);
            }
            
            if (idcValues.length < 2) {
                 errors.push(`Block ${blockIndex + 1} (${centerLegName}): Not enough data rows.`);
                 return;
            }

            for (let i = 1; i < headers.length; i++) {
                allSeries.push({
                    centerLegCoreName: centerLegName,
                    nValue: nValue,
                    model: headers[i],
                    idc: idcValues,
                    inductance: inductanceData[i-1],
                    lInitialOverride: lInitialOverrideValues[i-1] // Can be undefined if not found
                });
            }
        });
        
        document.getElementById('processingErrors').innerHTML = errors.join('<br>');
        return allSeries;
    }

    /**
     * UPDATED: This function now uses the L_initial override value for the final data object,
     * while the calculation continues to use the measured Idc=0 value.
     */
    function calculateAndBuildFinalData(series) {
        return series.map(s => {
            // Calculation uses the measured data table (s.inductance) where index 0 is Idc=0
            const idc_70 = findIdcForTarget(s.idc, s.inductance, 70);
            const idc_80 = findIdcForTarget(s.idc, s.inductance, 80);

            // The final L_initial value for display/graphing is the override value.
            // If the override is not found, it falls back to the measured Idc=0 value.
            const final_L_initial = s.lInitialOverride !== undefined && !isNaN(s.lInitialOverride) 
                ? s.lInitialOverride 
                : s.inductance[0];

            return {
                centerLegCore: `${s.centerLegCoreName}_N${s.nValue}`,
                outerCoreShell: s.model,
                L_initial: final_L_initial,
                Idc_70: idc_70,
                Idc_80: idc_80,
                Gap: 0,
                N: s.nValue,
                FoM: idc_80 ? final_L_initial * idc_80 : 0,
            };
        }).filter(d => d.L_initial > 0 && d.Idc_70 !== null && d.Idc_80 !== null);
    }
    
    function formatForAnalysisTool(data) {
        const grouped = data.reduce((acc, item) => {
            if (!acc[item.centerLegCore]) { acc[item.centerLegCore] = []; }
            acc[item.centerLegCore].push(item);
            return acc;
        }, {});

        let output = '';
        for (const groupName in grouped) {
            const items = grouped[groupName];
            const shells = items.map(d => d.outerCoreShell).join('\t');
            const l_initials = items.map(d => d.L_initial.toFixed(2)).join('\t');
            const idc_70s = items.map(d => d.Idc_70.toFixed(2)).join('\t');
            const idc_80s = items.map(d => d.Idc_80.toFixed(2)).join('\t');
            const gaps = items.map(d => d.Gap.toFixed(1)).join('\t');
            const ns = items.map(d => d.N).join('\t');
            
            output += `${groupName}\t${shells}\n`;
            output += `L_initial(uH)\t${l_initials}\n`;
            output += `Idc_70%(A)\t${idc_70s}\n`;
            output += `Idc_80%(A)\t${idc_80s}\n`;
            output += `Gap(mm)\t${gaps}\n`;
            output += `N\t${ns}\n\n`;
        }
        return output;
    }
    
    document.getElementById('processBtn').addEventListener('click', () => {
        const rawText = document.getElementById('rawInput').value;
        if (!rawText.trim()) { alert('Please paste raw data first.'); return; }
        const parsedSeries = parseRawData(rawText);
        if(parsedSeries.length === 0) { alert('Could not parse any valid data. Please check the format and error messages.'); return; }
        const finalData = calculateAndBuildFinalData(parsedSeries);
        if(finalData.length === 0) { alert('Data was parsed, but calculations failed for all entries. Check if Idc=0 data is present.'); return; }
        const formattedText = formatForAnalysisTool(finalData);
        document.getElementById('dataInput').value = formattedText;
        document.getElementById('analysisContainer').classList.remove('hidden');
        app.updateAll();
    });

    // --- END: Integration Logic ---


    // --- START: Analysis App Logic (No changes needed below this line) ---
    const app = {
        elements: {}, chartInstance: null, parsedData: [],
        defaultColors: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
        pointStyles: ['circle', 'rect', 'triangle', 'rectRot', 'star', 'cross', 'rectRounded'],
        init() { this.cacheElements(); this.addEventListeners(); },
        cacheElements() { const ids = [ 'dataInput', 'xAxis', 'yAxis', 'centerLegFilterControls', 'outerCoreFilterControls', 'mainChart', 'statsTableBody', 'dataCount', 'chartStatus', 'btnExportCSV', 'btnExportPNG', 'parsedDataTableBody', 'selectAllCenterLegs', 'deselectAllCenterLegs', 'selectAllOuterCores', 'deselectAllOuterCores' ]; ids.forEach(id => this.elements[id] = document.getElementById(id)); },
        addEventListeners() { const controlsToRedrawChart = ['xAxis', 'yAxis', 'centerLegFilterControls', 'outerCoreFilterControls']; controlsToRedrawChart.forEach(id => this.elements[id].addEventListener('change', () => this.updateUI())); this.elements.btnExportCSV.addEventListener('click', () => this.exportCSV()); this.elements.btnExportPNG.addEventListener('click', () => this.exportPNG()); this.elements.selectAllCenterLegs.addEventListener('click', () => { this.setAllCheckboxes(this.elements.centerLegFilterControls, true); this.updateUI(); }); this.elements.deselectAllCenterLegs.addEventListener('click', () => { this.setAllCheckboxes(this.elements.centerLegFilterControls, false); this.updateUI(); }); this.elements.selectAllOuterCores.addEventListener('click', () => { this.setAllCheckboxes(this.elements.outerCoreFilterControls, true); this.updateUI(); }); this.elements.deselectAllOuterCores.addEventListener('click', () => { this.setAllCheckboxes(this.elements.outerCoreFilterControls, false); this.updateUI(); }); },
        setAllCheckboxes(container, isChecked) { container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = isChecked); },
        parseData() { const lines = this.elements.dataInput.value.trim().split('\n'); const result = []; let currentBlock = this.createEmptyBlock(); const flushBlock = () => { if (!currentBlock.centerLegCore) return; const { centerLegCore, outerCoreShells, lValues, idc70Values, idc80Values, gapValues, nValues } = currentBlock; const n = Math.min(outerCoreShells.length, lValues.length, idc70Values.length, idc80Values.length, gapValues.length, nValues.length); for (let i = 0; i < n; i++) { const L = lValues[i], I70 = idc70Values[i], I80 = idc80Values[i], G = gapValues[i], N = nValues[i]; if ([L, I70, I80, G, N].some(v => v === undefined || isNaN(v))) continue; result.push({ centerLegCore: centerLegCore, outerCoreShell: String(outerCoreShells[i]), L_initial: L, Idc_70: I70, Idc_80: I80, Gap: G, N: N, FoM: L * I80, }); } currentBlock = this.createEmptyBlock(); }; for (const line of lines) { const trimmedLine = line.trim(); if (!trimmedLine) continue; const parts = trimmedLine.split(/\s+/); const label = parts[0].toLowerCase(); if (label.startsWith('clc_')) { flushBlock(); currentBlock.centerLegCore = parts[0]; currentBlock.outerCoreShells = parts.slice(1); } else if (label.startsWith('l_initial')) { currentBlock.lValues = parts.slice(1).map(parseFloat); } else if (label.startsWith('idc_70%')) { currentBlock.idc70Values = parts.slice(1).map(parseFloat); } else if (label.startsWith('idc_80%')) { currentBlock.idc80Values = parts.slice(1).map(parseFloat); } else if (label.startsWith('gap(mm)')) { currentBlock.gapValues = parts.slice(1).map(parseFloat); } else if (label.startsWith('n')) { currentBlock.nValues = parts.slice(1).map(parseFloat); } } flushBlock(); return result; },
        createEmptyBlock: () => ({ centerLegCore: null, outerCoreShells: [], lValues: [], idc70Values: [], idc80Values: [], gapValues: [], nValues: [] }),
        getFilteredData() { const selectedCenterLegs = new Set(Array.from(this.elements.centerLegFilterControls.querySelectorAll('input:checked')).map(chk => chk.dataset.value)); const selectedOuterShells = new Set(Array.from(this.elements.outerCoreFilterControls.querySelectorAll('input:checked')).map(chk => chk.dataset.value)); if (selectedCenterLegs.size === 0 || selectedOuterShells.size === 0) return []; return this.parsedData.filter(d => selectedCenterLegs.has(d.centerLegCore) && selectedOuterShells.has(d.outerCoreShell)); },
        groupData: (data, groupBy) => data.reduce((groups, item) => { const key = item[groupBy]; if (!groups[key]) groups[key] = []; groups[key].push(item); return groups; }, {}),
        updateAll() { this.parsedData = this.parseData(); const allCenterLegs = [...new Set(this.parsedData.map(d => d.centerLegCore))].sort(); const allOuterShells = [...new Set(this.parsedData.map(d => d.outerCoreShell))].sort((a, b) => a - b); this.updateFilterControls(this.elements.centerLegFilterControls, allCenterLegs, true); this.updateFilterControls(this.elements.outerCoreFilterControls, allOuterShells, true); this.updateParsedDataTable(); this.updateUI(); },
        updateUI() { const baseData = this.getFilteredData(); const groupedData = this.groupData(baseData, 'centerLegCore'); this.updateStatsTable(groupedData); this.createChart(); },
        updateParsedDataTable() { const { parsedDataTableBody, dataCount } = this.elements; parsedDataTableBody.innerHTML = ''; dataCount.textContent = `Total of ${this.parsedData.length} data points recognized`; if (this.parsedData.length === 0) { parsedDataTableBody.innerHTML = `<tr><td colspan="8">No data recognized.</td></tr>`; return; } let rows = ''; this.parsedData.forEach(d => { rows += `<tr><td>${d.centerLegCore}</td><td>${d.outerCoreShell}</td><td>${d.L_initial.toFixed(2)}</td><td>${d.Idc_70.toFixed(2)}</td><td>${d.Idc_80.toFixed(2)}</td><td>${d.Gap.toFixed(2)}</td><td>${d.N}</td><td>${d.FoM.toFixed(1)}</td></tr>`; }); parsedDataTableBody.innerHTML = rows; },
        updateFilterControls(container, values, checkAll = false) { const checkedState = new Map(); container.querySelectorAll('input[type="checkbox"]').forEach(chk => { checkedState.set(chk.dataset.value, chk.checked); }); container.innerHTML = ''; if (!values || values.length === 0) return; values.forEach(value => { const isChecked = checkAll ? 'checked' : (checkedState.has(value) ? (checkedState.get(value) ? 'checked' : '') : 'checked'); container.innerHTML += `<div class="filter-item"><input type="checkbox" id="chk-${container.id}-${value}" data-value="${value}" ${isChecked}><label for="chk-${container.id}-${value}">${value}</label></div>`; }); },
        updateStatsTable(groupedData) { const { statsTableBody } = this.elements; statsTableBody.innerHTML = ''; if (Object.keys(groupedData).length === 0) { statsTableBody.innerHTML = '<tr><td colspan="7">No data selected. Check filters.</td></tr>'; return; } for (const group in groupedData) { const items = groupedData[group]; const calcStats = (arr) => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0; statsTableBody.innerHTML += `<tr><td><strong>${group}</strong></td><td>${items.length}</td><td>${calcStats(items.map(d => d.L_initial)).toFixed(2)}</td><td>${calcStats(items.map(d => d.Idc_70)).toFixed(2)}</td><td>${calcStats(items.map(d => d.Idc_80)).toFixed(2)}</td><td>${calcStats(items.map(d => d.FoM)).toFixed(1)}</td><td>${calcStats(items.map(d => d.Gap)).toFixed(2)}</td></tr>`; } },
        showStatus(msg, isError = false) { const { chartStatus } = this.elements; chartStatus.textContent = msg; chartStatus.style.display = 'block'; chartStatus.style.background = isError ? 'rgba(200, 0, 0, 0.7)' : 'rgba(0, 0, 0, 0.7)'; },
        
        // ==================================================================
        // ===== ✨ MODIFIED SECTION START ✨ =====
        // ==================================================================
        createChart() {
            const baseData = this.getFilteredData();
            const groupedData = this.groupData(baseData, 'centerLegCore');
            const allCenterLegs = [...new Set(this.parsedData.map(d => d.centerLegCore))].sort();
            
            if (this.chartInstance) {
                this.chartInstance.destroy();
            }

            // 클릭으로 생성된 주석(레이블)을 저장할 배열을 초기화합니다.
            this.chartAnnotations = [];

            const ctx = this.elements.mainChart.getContext('2d');
            ctx.clearRect(0, 0, this.elements.mainChart.width, this.elements.mainChart.height);
            
            if (!baseData.length) {
                this.showStatus('No data to display.', true);
                return;
            }
            this.showStatus('Generating chart...');

            const { xAxis, yAxis } = this.elements;

            // 툴팁과 클릭 레이블에 사용될 텍스트를 생성하는 헬퍼 함수입니다.
            const getLabelText = (item) => {
                if (!item) return '';
                return [
                    `${item.centerLegCore} / Shell ${item.outerCoreShell}`,
                    `L=${item.L_initial.toFixed(1)} μH`,
                    `Idc_70=${item.Idc_70.toFixed(1)} A, Idc_80=${item.Idc_80.toFixed(1)} A`,
                    `Gap=${item.Gap.toFixed(1)} mm, N=${item.N}`,
                    `FoM=${item.FoM.toFixed(1)}`
                ];
            };

            const datasets = Object.keys(groupedData).map(group => {
                const coreIndex = allCenterLegs.indexOf(group);
                const color = this.defaultColors[coreIndex % this.defaultColors.length];
                const pointStyle = this.pointStyles[coreIndex % this.pointStyles.length];
                const data = groupedData[group].map(item => ({
                    x: item[xAxis.value],
                    y: item[yAxis.value],
                    raw: item
                }));
                return {
                    label: group,
                    data,
                    backgroundColor: color,
                    borderColor: color,
                    pointStyle: pointStyle,
                    radius: 6,
                    hoverRadius: 9
                };
            });

            // --- NEW: 클릭된 레이블을 그리기 위한 커스텀 플러그인 ---
            const annotationPlugin = {
                id: 'clickAnnotations',
                afterDraw: (chart) => {
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'bottom';

                    this.chartAnnotations.forEach(annotation => {
                        const model = chart.getDatasetMeta(annotation.datasetIndex).data[annotation.index];
                        if (!model) return;

                        const x = model.x + 10; // 점 옆에 약간의 간격을 둡니다.
                        const y = model.y;
                        const textLines = annotation.text;
                        const lineHeight = 14;
                        const textWidth = Math.max(...textLines.map(line => ctx.measureText(line).width));
                        
                        // 텍스트 뒤에 배경 상자를 그려 가독성을 높입니다.
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                        ctx.fillRect(x - 3, y - (lineHeight * textLines.length) - 3, textWidth + 6, (lineHeight * textLines.length) + 6);
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x - 3, y - (lineHeight * textLines.length) - 3, textWidth + 6, (lineHeight * textLines.length) + 6);

                        // 여러 줄의 텍스트를 그립니다.
                        ctx.fillStyle = '#333';
                        textLines.forEach((line, i) => {
                            ctx.fillText(line, x, y - (lineHeight * (textLines.length - 1 - i)));
                        });
                    });
                    ctx.restore();
                }
            };

            this.chartInstance = new Chart(this.elements.mainChart, {
                type: 'scatter',
                data: { datasets },
                plugins: [annotationPlugin], // 커스텀 플러그인을 등록합니다.
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    // --- NEW: onClick 이벤트 핸들러 ---
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const { datasetIndex, index } = elements[0];
                            const item = this.chartInstance.data.datasets[datasetIndex].data[index].raw;

                            // 이 점에 대한 레이블이 이미 있는지 확인합니다.
                            const existingAnnotationIndex = this.chartAnnotations.findIndex(
                                a => a.datasetIndex === datasetIndex && a.index === index
                            );

                            if (existingAnnotationIndex > -1) {
                                // 이미 있다면 제거합니다 (토글 기능).
                                this.chartAnnotations.splice(existingAnnotationIndex, 1);
                            } else {
                                // 없다면 새로 추가합니다.
                                this.chartAnnotations.push({
                                    datasetIndex,
                                    index,
                                    text: getLabelText(item)
                                });
                            }
                            // 차트를 다시 그려서 변경사항을 반영합니다.
                            this.chartInstance.update('none'); // 'none'은 애니메이션 없이 업데이트합니다.
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: { usePointStyle: true, padding: 20 }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const item = context.raw?.raw;
                                    return getLabelText(item);
                                }
                            }
                        }
                    },
                    scales: {
                        x: { title: { display: true, text: xAxis.options[xAxis.selectedIndex].text } },
                        y: { title: { display: true, text: yAxis.options[yAxis.selectedIndex].text } }
                    }
                }
            });
            setTimeout(() => this.elements.chartStatus.style.display = 'none', 1000);
        },
        // ==================================================================
        // ===== ✨ MODIFIED SECTION END ✨ =====
        // ==================================================================
        exportCSV() { const data = this.getFilteredData(); if (data.length === 0) { alert('No data selected to export.'); return; } const headers = "CenterLegCore,OuterCoreShell,L_initial(uH),Idc_70%(A),Idc_80%(A),Gap(mm),N,FoM"; const rows = data.map(d => `${d.centerLegCore},${d.outerCoreShell},${d.L_initial},${d.Idc_70},${d.Idc_80},${d.Gap},${d.N},${d.FoM.toFixed(2)}`); const csvContent = "data:text/csv;charset=utf-8," + [headers, ...rows].join("\n"); const encodedUri = encodeURI(csvContent); const link = document.createElement("a"); link.setAttribute("href", encodedUri); link.setAttribute("download", "inductance_data_export.csv"); document.body.appendChild(link); link.click(); document.body.removeChild(link); },
        exportPNG() { if (!this.chartInstance || !this.getFilteredData().length) { alert('No chart available to export.'); return; } const url = this.chartInstance.toBase64Image(); const link = document.createElement('a'); link.download = 'inductance_chart.png'; link.href = url; link.click(); }
    };
    app.init();
    // --- END: Analysis App Logic ---
});
</script>
</body>
</html>
