<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Integrated Inductance Analysis Tool (L_initial Logic)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family: 'Arial', sans-serif; background:#f5f5f5; padding:20px; }
        .container { max-width:1000px; margin:0 auto; background:#fff; border-radius:10px; padding:30px; box-shadow:0 2px 10px rgba(0,0,0,.1); }
        .title { font-size:28px; font-weight:700; color:#333; margin-bottom:30px; text-align:center; }
        .section { margin-bottom:30px; }
        .section-title { font-size:20px; font-weight:700; color:#444; margin-bottom:15px; border-bottom:2px solid #007bff; padding-bottom:5px; }
        .data-input { width:100%; height:250px; padding:15px; border:2px solid #ddd; border-radius:8px; font-family:'Courier New', monospace; font-size:12px; resize:vertical; }
        .controls { display:grid; grid-template-columns:repeat(auto-fit, minmax(200px,1fr)); gap:20px; background:#f8f9fa; padding:20px; border-radius:8px; }
        .control-group { display:flex; flex-direction:column; }
        .control-group label { font-weight:700; margin-bottom:6px; color:#555; }
        .control-group select { padding:8px; border:1px solid #ccc; border-radius:5px; font-size:14px; }
        .control-group select:disabled { background-color: #eee; cursor: not-allowed; }
        .chart-container { position:relative; height:500px; margin:20px 0; background:#fff; border:1px solid #ddd; border-radius:8px; padding:20px; }
        #chartStatus { position:absolute; top:10px; right:10px; background:rgba(0,0,0,.7); color:#fff; padding:5px 10px; border-radius:5px; font-size:14px; display:none; }
        .table-wrapper { max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; margin-top: 15px; }
        .stats-table { width:100%; border-collapse:collapse; background:#fff; font-size:13px; }
        .stats-table th, .stats-table td { padding:8px; text-align:center; border-bottom:1px solid #eee; }
        .stats-table th { background:#007bff; color:#fff; font-weight:700; font-size:11px; position: sticky; top: 0; z-index: 1; }
        .stats-table tr:nth-child(even){ background:#f8f9fa; }
        .stats-table tr:hover{ background:#e3f2fd; }
        .data-count { background:#28a745; color:#fff; padding:5px 10px; border-radius:15px; font-size:12px; margin-top:10px; display:inline-block; }
        .btn { background:#007bff; color:#fff; border:none; padding:12px 25px; border-radius:8px; cursor:pointer; font-size:16px; margin:5px; transition: background-color 0.3s ease; }
        .btn:hover{ background:#0056b3; }
        .btn-secondary{ background:#6c757d; }
        .btn-secondary:hover{ background:#545b62; }
        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; background-color: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #ddd; max-height: 200px; overflow-y: auto; }
        .filter-item { display: flex; align-items: center; background: #fff; padding: 8px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-size: 13px; }
        .filter-item input { margin-right: 10px; }
        .filter-item label { display: flex; align-items: center; cursor: pointer; flex: 1; }
        .filter-actions { margin-bottom: 10px; }
        .btn-filter { background: #6c757d; color: white; border: none; padding: 5px 10px; font-size: 12px; border-radius: 4px; cursor: pointer; margin-right: 5px; }
        .btn-filter:hover { background: #5a6268; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">🚀 Integrated Inductance Analysis Tool (L_initial Logic)</h1>
        
        <div class="section">
            <h2 class="section-title">Step 1: Paste Raw Data</h2>
            <textarea id="rawInput" class="data-input" placeholder="이곳에 데이터를 붙여넣으세요.
L_initial 행을 포함해야 합니다.

BLOCK: CLC_6x22x4.1R1, N: 40(6T_0.1x50p)								
Idc(A)	139	140	141	143	144	145	146	147
0	128.3	127.2	118.8	130.7	134.2	133.1	132.6	132.9
10	109.1	111.3	102.3	112.6	118	116.9	116.7	116.9
13.5	98.8	103.1	93.5	104	109.8	108.7	108.7	108.6
14.5	95.8	100.7	90.9	101.7	107.5	106.4	106.3	106.3
15	94.4	99.4	89.7	100.5	106.3	105.3	105.2	105.3
Gap(mm)	3.1	3.1	4.1	3.1	3.1	3.1	3.1	3.1
L_initial	131.1	130	121.1	133.8	137.4	136.2	135.6	136
								
BLOCK: CLC_6x22x4.1R0, N: 40(6T_0.1x50p)								
Idc(A)	139	140	141	143	144	145	146	147
0	130.5	129.9	121	136.1	136.9	135.8	135.3	135.6
10	110.2	113.3	103.7	116.1	119.5	118.6	118.4	118.5
13.5	99.2	104.4	94.4	106.3	110.8	109.9	109.9	109.8
14.5	96.1	101.8	91.6	103.5	108.4	107.3	107.4	107.3
15	94.7	100.4	90.2	101.9	106.8	106	106.2	106
Gap(mm)	3.1	3.1	4.1	3.1	3.1	3.1	3.1	3.1
L_initial	133.9	132.9	123.4	139.3	140.1	139	138.4	138.9
								
BLOCK: CLC_8x22x4.1R1, N: 38(6T_0.1x50p)								
Idc(A)	139	140	141	143	144	145	146	147
0	129.7	129.2	120.5	133.3	135.8	134.9	134.4	134.8
10	108.7	111.8	102.3	113.5	117.9	117.3	117.1	117.1
13.5	97.3	102.6	92.4	103.8	109.2	108.5	108.4	108.3
14.5	94.1	99.9	89.6	100.9	106.6	105.8	105.7	105.7
15	92.6	98.5	88.2	99.7	105.2	104.4	104.6	104.4
Gap(mm)	3.1	3.1	4.1	3.1	3.1	3.1	3.1	3.1
L_initial	132.9	132	122.9	136.4	139.3	137.9	137.3	137.8
								
BLOCK: CLC_8x22x4.1R1, N: 37(6T_0.1x50p)								
Idc(A)	139	140	141	143	144	145	146	147
0	122.9	122.1	114.1	126.3	128.8	127.9	127.4	127.8
10	104.1	106.8	97.9	108.6	112.8	112.2	111.9	112.1
13.5	93.8	98.5	89.1	99.7	104.9	104.1	104	104
14.5	90.9	96	86.5	97.1	102.5	101.7	101.6	101.7
15	89.5	94.7	85.2	95.7	101.5	100.5	100.6	100.5
Gap(mm)	3.1	3.1	4.1	3.1	3.1	3.1	3.1	3.1
L_initial	125.7	124.6	116.1	128.9	131.8	130.7	130.1	130.5
								
BLOCK: CLC_6x22x4.1R0, N: 40(6T_0.1x50p)								
Idc(A)	139	140	141	143	144	145	146	147
0	130.5	129.9	121	136.1	136.9	135.8	135.3	135.6
10	110.2	113.3	103.7	116.1	119.5	118.6	118.4	118.5
13.5	99.2	104.4	94.4	106.3	110.8	109.9	109.9	109.8
14.5	96.1	101.8	91.6	103.5	108.4	107.3	107.4	107.3
15	94.7	100.4	90.2	101.9	106.8	106	106.2	106
Gap(mm)	3.1	3.1	4.1	3.1	3.1	3.1	3.1	3.1
L_initial	133.9	132.9	123.4	139.3	140.1	139	138.4	138.9
								
BLOCK: CLC_6x22x4.1R1, N: 30(6T_0.1x60p)								
Idc(A)	139	142	143	144	145	147		
0	71.3	73.5	73.6	73.9	73.5	73.4		
10	65.7	67.4	67.9	69.3	68.7	68.8		
13.5	62.2	63.6	64.8	66.6	66	66.2		
15	60.5	61.9	63.4	65.4	64.8	64.9		
19	55.9	56.9	59.5	62.1	61.6	61.6		
Gap(mm)	3.1	3.1	3.1	3.1	3.1	3.1		
L_initial	71.8	74.5	74.3	74.7	74.3	74.2		
								
BLOCK: CLC_6x22x4.1R1, N: 31(6T_0.1x70p)								
Idc(A)	139	144	145	147				
0	78.06	81.3	81	81				
10	70.9	75.3	75	75				
13.5	66.5	72	71.8	71.8				
15	64.4	70.5	70.2	70.3				
19	58.7	66.3	66	66				
20	57.4	65.6	64.9	64.8				
23	53	62	61.4	61.4				
Gap(mm)	3.1	3.1	3.1	3.1				
L_initial	79.6	83.05	82.7	82.5				
								
BLOCK: CLC_6x22x4.1R1, N: 47(6T_0.1x50p)								
Idc(A)	145							
0	183.2							
5	170							
10	151.5							
11	147.4							
11.5	145.4							
12	143.5							
13.5	137.6							
Gap(mm)	3.1							
L_initial	190.3							
								
BLOCK: CLC_6x22x4.1R1, N: 46(6T_0.1x50p)								
Idc(A)	145							
0	175							
5	164							
10	146.3							
11	142.5							
11.5	140.6							
12	138.7							
13.5	133.2							
Gap(mm)	3.1							
L_initial	181.2							

"></textarea>
            <div style="text-align: center; margin-top: 20px;">
                <button id="processBtn" class="btn">📊 Process and Analyze Data</button>
            </div>
             <div id="processingErrors" style="margin-top:15px; font-size:13px; color:#c00; font-family:'Courier New', monospace;"></div>
        </div>

                <textarea id="dataInput" class="data-input hidden"></textarea>

        <div id="analysisContainer" class="hidden">
            <hr style="margin: 40px 0;">
            <h2 class="section-title" style="text-align: center; font-size: 24px; border-bottom: none;">Step 2: Analysis Results</h2>
            <div class="section">
                <h2 class="section-title">Parsed Data Confirmation</h2>
                <div id="dataCount" class="data-count">Waiting for data...</div>
                <div class="table-wrapper">
                    <table class="stats-table" id="parsedDataTable">
                        <thead>
                            <tr>
                                <th>Center Leg</th><th>Outer Shell</th><th>L_initial(uH)</th><th>Idc_70%(A)</th><th>Idc_80%(A)</th><th>Gap(mm)</th><th>N</th><th>FoM</th>
                            </tr>
                        </thead>
                        <tbody id="parsedDataTableBody"></tbody>
                    </table>
                </div>
            </div>
            <div class="section">
                <h2 class="section-title">Center Leg Core Filter</h2>
                <div class="filter-actions">
                    <button class="btn-filter" id="selectAllCenterLegs">Select All</button>
                    <button class="btn-filter" id="deselectAllCenterLegs">Deselect All</button>
                </div>
                <div class="filter-controls" id="centerLegFilterControls"></div>
            </div>
            <div class="section">
                <h2 class="section-title">Outer Core Shell Filter</h2>
                <div class="filter-actions">
                    <button class="btn-filter" id="selectAllOuterCores">Select All</button>
                    <button class="btn-filter" id="deselectAllOuterCores">Deselect All</button>
                </div>
                <div class="filter-controls" id="outerCoreFilterControls"></div>
            </div>
            <div class="section">
                <h2 class="section-title">Analysis Options</h2>
                <div class="controls">
                                        <div class="control-group">
                        <label for="plotType">Plot Type</label>
                        <select id="plotType">
                            <option value="summary" selected>Summary Data (Calculated)</option>
                            <option value="raw">Raw L vs. Idc</option>
                        </select>
                    </div>
                    <div class="control-group"><label for="xAxis">X-Axis (Summary)</label><select id="xAxis"><option value="Idc_80">Idc 80% (A)</option><option value="Idc_70">Idc 70% (A)</option><option value="L_initial">Inductance (μH)</option><option value="FoM">FoM (L×Idc)</option><option value="Gap">Gap (mm)</option></select></div>
                    <div class="control-group"><label for="yAxis">Y-Axis (Summary)</label><select id="yAxis"><option value="L_initial">Inductance (μH)</option><option value="Idc_80">Idc 80% (A)</option><option value="Idc_70">Idc 70% (A)</option><option value="FoM">FoM (L×Idc)</option><option value="Gap">Gap (mm)</option></select></div>
                    <div class="control-group"><label>&nbsp;</label><button class="btn btn-secondary" id="btnExportCSV">Export Selected Data to CSV</button></div>
                    <div class="control-group"><label>&nbsp;</label><button class="btn btn-secondary" id="btnExportPNG">Export Chart to PNG</button></div>
                </div>
            </div>
            <div class="section">
                <h2 class="section-title">Analysis Chart</h2>
                <div class="chart-container"><canvas id="mainChart"></canvas><div id="chartStatus">Loading...</div></div>
            </div>
            <div class="section">
                <h2 class="section-title">Statistics Summary (Based on selected data)</h2>
                <div class="table-wrapper" style="max-height: none;">
                    <table class="stats-table" id="statsTable">
                        <thead><tr><th>Group (Center Leg)</th><th>Count</th><th>L Avg (μH)</th><th>Idc_70% Avg (A)</th><th>Idc_80% Avg (A)</th><th>FoM Avg</th><th>Gap Avg (mm)</th></tr></thead>
                        <tbody id="statsTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

<script>
// --- START: Calculation Logic (Interpolation/Extrapolation) ---
// (No changes in this block)
class CubicSpline {
    constructor(x, y) { this.x = [...x]; this.y = [...y]; this.n = x.length; this.calculateCoefficients(); }
    calculateCoefficients() { const n = this.n; const h = new Array(n - 1); for (let i = 0; i < n - 1; i++) h[i] = this.x[i + 1] - this.x[i]; const alpha = new Array(n - 1); for (let i = 1; i < n - 1; i++) alpha[i] = (3 / h[i]) * (this.y[i + 1] - this.y[i]) - (3 / h[i - 1]) * (this.y[i] - this.y[i - 1]); const l = new Array(n); const mu = new Array(n); const z = new Array(n); l[0] = 1; mu[0] = 0; z[0] = 0; for (let i = 1; i < n - 1; i++) { l[i] = 2 * (this.x[i + 1] - this.x[i - 1]) - h[i - 1] * mu[i - 1]; mu[i] = h[i] / l[i]; z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i]; } l[n - 1] = 1; z[n - 1] = 0; this.c = new Array(n); this.b = new Array(n - 1); this.d = new Array(n - 1); this.c[n - 1] = 0; for (let j = n - 2; j >= 0; j--) { this.c[j] = z[j] - mu[j] * this.c[j + 1]; this.b[j] = (this.y[j + 1] - this.y[j]) / h[j] - h[j] * (this.c[j + 1] + 2 * this.c[j]) / 3; this.d[j] = (this.c[j + 1] - this.c[j]) / (3 * h[j]); } }
    interpolate(x) { if (x < this.x[0] || x > this.x[this.n-1]) return null; let i = 0; for (i = 0; i < this.n - 1; i++) if (x <= this.x[i + 1]) break; const dx = x - this.x[i]; return this.y[i] + this.b[i] * dx + this.c[i] * dx * dx + this.d[i] * dx * dx * dx; }
    findX(targetY, tolerance = 0.001) { let left = this.x[0], right = this.x[this.n - 1]; let iterations = 0; const maxIterations = 200; while (right - left > tolerance && iterations < maxIterations) { const mid = (left + right) / 2; const midY = this.interpolate(mid); if (midY === null) return { value: null }; if (midY > targetY) left = mid; else right = mid; iterations++; } const finalValue = (left + right) / 2; return { value: finalValue, isExtrapolated: false }; }
}
function polynomialRegression(x, y) { const n = x.length; let sumX = 0, sumY = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0, sumXY = 0, sumX2Y = 0; for (let i = 0; i < n; i++) { sumX += x[i]; sumY += y[i]; sumX2 += x[i] * x[i]; sumX3 += x[i] * x[i] * x[i]; sumX4 += x[i] * x[i] * x[i] * x[i]; sumXY += x[i] * y[i]; sumX2Y += x[i] * x[i] * y[i]; } const SXX = sumX2 - sumX * sumX / n; const SXY = sumXY - sumX * sumY / n; const SXX2 = sumX3 - sumX * sumX2 / n; const SX2Y = sumX2Y - sumX2 * sumY / n; const SX2X2 = sumX4 - sumX2 * sumX2 / n; const denominator = (SX2X2 * SXX - SXX2 * SXX2); if (Math.abs(denominator) < 1e-10) return null; const a = (SX2Y * SXX - SXY * SXX2) / denominator; const b = (SXY * SX2X2 - SX2Y * SXX2) / denominator; const c = sumY / n - b * sumX / n - a * sumX2 / n; const yMean = sumY / n; let sst = 0, sse = 0; for (let i = 0; i < n; i++) { sst += (y[i] - yMean) * (y[i] - yMean); const predictedY = a * x[i] * x[i] + b * x[i] + c; sse += (y[i] - predictedY) * (y[i] - predictedY); } const r2 = 1 - (sse / sst); return { coefficients: [a, b, c], r2 }; }
function solveQuadratic(a, b, c, context, range) { const discriminant = b * b - 4 * a * c; if (discriminant < 0) return null; const root1 = (-b + Math.sqrt(discriminant)) / (2 * a); const root2 = (-b - Math.sqrt(discriminant)) / (2 * a); if (context === 'upper') { return root1 > range[1] ? root1 : (root2 > range[1] ? root2 : null); } if (context === 'lower') { return root1 < range[0] ? root1 : (root2 < range[0] ? root2 : null); } return null; }
function findIdcForTarget(idcValues, inductanceValues, targetPercentage) { const initialInductance = inductanceValues[0]; if (initialInductance === 0) return null; const normalizedInductance = inductanceValues.map(val => (val / initialInductance) * 100); const minInductance = Math.min(...normalizedInductance); const maxInductance = Math.max(...normalizedInductance); let resultIdc = null; if (targetPercentage >= minInductance && targetPercentage <= maxInductance) { const spline = new CubicSpline(idcValues, normalizedInductance); const splineResult = spline.findX(targetPercentage); resultIdc = splineResult.value; } else { const regression = polynomialRegression(idcValues, normalizedInductance); if (regression && regression.r2 >= 0.95) { const [a, b, c] = regression.coefficients; const c_prime = c - targetPercentage; const context = targetPercentage < minInductance ? 'upper' : 'lower'; const idcRange = [Math.min(...idcValues), Math.max(...idcValues)]; resultIdc = solveQuadratic(a, b, c_prime, context, idcRange); } } return resultIdc; }
// --- END: Calculation Logic ---


// --- START: Main Application Logic ---
document.addEventListener('DOMContentLoaded', () => {

    // --- START: Integration & Data Transformation Logic ---
    
    /**
     * (No changes)
     */
    function parseRawData(text) {
        const blocks = text.trim().split(/\n\s*\n/);
        const allSeries = [];
        const errors = [];
        const metaRegex = /^BLOCK:\s*(.+?)(?:,?\s*N:\s*(\d+))/i;

        blocks.forEach((block, blockIndex) => {
            if (!block.trim()) return;

            const lines = block.trim().split('\n');
            const metaLine = lines[0];
            const match = metaLine.match(metaRegex);

            if (!match) {
                errors.push(`Block ${blockIndex + 1}: Invalid BLOCK format.`);
                return;
            }

            const centerLegName = match[1].trim();
            const nValue = match[2] ? parseInt(match[2], 10) : 0;

            const headerLineIndex = lines.findIndex(l => l.toLowerCase().startsWith('idc(a)'));
            if (headerLineIndex === -1) {
                errors.push(`Block ${blockIndex + 1} (${centerLegName}): Could not find 'Idc(A)' header.`);
                return;
            }
            
            const headers = lines[headerLineIndex].trim().split(/\s+/);
            let idcValues = [];
            let inductanceData = Array.from({ length: headers.length - 1 }, () => []);
            let tableEndIndex = headerLineIndex;

            for (let i = headerLineIndex + 1; i < lines.length; i++) {
                const parts = lines[i].trim().split(/\s+/);
                if (parts.length < headers.length || isNaN(parseFloat(parts[0]))) {
                    tableEndIndex = i;
                    break;
                }
                idcValues.push(parseFloat(parts[0]));
                for (let j = 1; j < headers.length; j++) {
                    inductanceData[j - 1].push(parseFloat(parts[j]));
                }
                tableEndIndex = i + 1;
            }

            let lInitialOverrideValues = [];
            const lInitialLine = lines.slice(tableEndIndex).find(l => l.toLowerCase().startsWith('l_initial'));
            if (lInitialLine) {
                lInitialOverrideValues = lInitialLine.trim().split(/\s+/).slice(1).map(parseFloat);
            } else {
                errors.push(`Block ${blockIndex + 1} (${centerLegName}): WARNING - 'L_initial' row not found. Using Idc=0 value.`);
Example (assuming `app.updateAll` is modified to accept data):
            }
            
            if (idcValues.length < 2) {
                 errors.push(`Block ${blockIndex + 1} (${centerLegName}): Not enough data rows.`);
                 return;
            }

            for (let i = 1; i < headers.length; i++) {
                // Ensure there is data for this column
                if (inductanceData[i-1] && inductanceData[i-1].length > 0) {
                    allSeries.push({
                        centerLegCoreName: centerLegName,
                        nValue: nValue,
                        model: headers[i],
                        idc: idcValues,
                        inductance: inductanceData[i-1],
                        lInitialOverride: lInitialOverrideValues[i-1] 
                    });
                }
            }
        });
        
        document.getElementById('processingErrors').innerHTML = errors.join('<br>');
        return allSeries;
    }

    /**
     * ✨ UPDATED: This function now adds the rawIdc and rawInductance arrays
     * to the final data object for later use in plotting.
     */
    function calculateAndBuildFinalData(series) {
        return series.map(s => {
            const idc_70 = findIdcForTarget(s.idc, s.inductance, 70);
            const idc_80 = findIdcForTarget(s.idc, s.inductance, 80);

            const final_L_initial = s.lInitialOverride !== undefined && !isNaN(s.lInitialOverride) 
                ? s.lInitialOverride 
                : s.inductance[0];

            return {
                // Original summary data
                centerLegCore: `${s.centerLegCoreName}_N${s.nValue}`,
                outerCoreShell: s.model,
                L_initial: final_L_initial,
                Idc_70: idc_70,
                Idc_80: idc_80,
                Gap: 0, 
                N: s.nValue,
                FoM: idc_80 ? final_L_initial * idc_80 : 0,
                
                // --- NEW: Added raw data for plotting ---
                rawIdc: s.idc,
                rawInductance: s.inductance
            };
        }).filter(d => d.L_initial > 0 && d.Idc_70 !== null && d.Idc_80 !== null);
    }
    
    /**
     * (No changes) This function is now effectively unused by the primary flow 
     * but is left here.
     */
    function formatForAnalysisTool(data) {
        const grouped = data.reduce((acc, item) => {
            if (!acc[item.centerLegCore]) { acc[item.centerLegCore] = []; }
            acc[item.centerLegCore].push(item);
            return acc;
        }, {});

        let output = '';
        for (const groupName in grouped) {
            const items = grouped[groupName];
            const shells = items.map(d => d.outerCoreShell).join('\t');
            const l_initials = items.map(d => d.L_initial.toFixed(2)).join('\t');
            const idc_70s = items.map(d => d.Idc_70.toFixed(2)).join('\t');
            const idc_80s = items.map(d => d.Idc_80.toFixed(2)).join('\t');
            const gaps = items.map(d => d.Gap.toFixed(1)).join('\t');
            const ns = items.map(d => d.N).join('\t');
            
            output += `${groupName}\t${shells}\n`;
            output += `L_initial(uH)\t${l_initials}\n`;
            output += `Idc_70%(A)\t${idc_70s}\n`;
            output += `Idc_80%(A)\t${idc_80s}\n`;
            output += `Gap(mm)\t${gaps}\n`;
            output += `N\t${ns}\n\n`;
        }
        return output;
    }
    
    /**
     * ✨ UPDATED: This listener now directly sets app.parsedData
     * with the full data object, instead of writing to/reading from
     * the hidden textarea, which was losing the raw data arrays.
     */
    document.getElementById('processBtn').addEventListener('click', () => {
        const rawText = document.getElementById('rawInput').value;
        if (!rawText.trim()) { alert('Please paste raw data first.'); return; }
        const parsedSeries = parseRawData(rawText);
        if(parsedSeries.length === 0) { alert('Could not parse any valid data. Please check the format and error messages.'); return; }
        const finalData = calculateAndBuildFinalData(parsedSeries);
        if(finalData.length === 0) { alert('Data was parsed, but calculations failed for all entries. Check if Idc=0 data is present.'); return; }
        
        // --- MODIFIED DATA FLOW ---
        // We no longer put formatted text into #dataInput.
        // Instead, we directly set the app's data variable.
        app.parsedData = finalData;
        
        document.getElementById('analysisContainer').classList.remove('hidden');
        
        // Now call updateAll(), which will use app.parsedData
        app.updateAll();
    });

    // --- END: Integration Logic ---


    // --- START: Analysis App Logic ---
    const app = {
        elements: {}, chartInstance: null, parsedData: [],
        defaultColors: ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
        pointStyles: ['circle', 'rect', 'triangle', 'rectRot', 'star', 'cross', 'rectRounded'],
        init() { this.cacheElements(); this.addEventListeners(); },
        cacheElements() {
            // ✨ ADDED 'plotType'
            const ids = [ 'dataInput', 'plotType', 'xAxis', 'yAxis', 'centerLegFilterControls', 'outerCoreFilterControls', 'mainChart', 'statsTableBody', 'dataCount', 'chartStatus', 'btnExportCSV', 'btnExportPNG', 'parsedDataTableBody', 'selectAllCenterLegs', 'deselectAllCenterLegs', 'selectAllOuterCores', 'deselectAllOuterCores' ]; 
            ids.forEach(id => this.elements[id] = document.getElementById(id)); 
        },
        addEventListeners() {
            // ✨ ADDED 'plotType' to controls that redraw the chart
            const controlsToRedrawChart = ['plotType', 'xAxis', 'yAxis', 'centerLegFilterControls', 'outerCoreFilterControls']; 
            controlsToRedrawChart.forEach(id => this.elements[id].addEventListener('change', () => this.updateUI())); 
            this.elements.btnExportCSV.addEventListener('click', () => this.exportCSV()); 
            this.elements.btnExportPNG.addEventListener('click', () => this.exportPNG()); 
            this.elements.selectAllCenterLegs.addEventListener('click', () => { this.setAllCheckboxes(this.elements.centerLegFilterControls, true); this.updateUI(); }); 
            this.elements.deselectAllCenterLegs.addEventListener('click', () => { this.setAllCheckboxes(this.elements.centerLegFilterControls, false); this.updateUI(); }); 
            this.elements.selectAllOuterCores.addEventListener('click', () => { this.setAllCheckboxes(this.elements.outerCoreFilterControls, true); this.updateUI(); }); 
            this.elements.deselectAllOuterCores.addEventListener('click', () => { this.setAllCheckboxes(this.elements.outerCoreFilterControls, false); this.updateUI(); }); 
        },
        setAllCheckboxes(container, isChecked) { container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = isChecked); },
        
        /**
         * This function is no longer called by the primary workflow,
         * as app.parsedData is set directly by the 'processBtn' listener.
         * It is left for potential legacy use.
         */
        parseData() { 
            // This function doesn't support the new raw data arrays,
            // which is why we bypass it.
            const lines = this.elements.dataInput.value.trim().split('\n'); 
            const result = []; 
            let currentBlock = this.createEmptyBlock(); 
            const flushBlock = () => { if (!currentBlock.centerLegCore) return; const { centerLegCore, outerCoreShells, lValues, idc70Values, idc80Values, gapValues, nValues } = currentBlock; const n = Math.min(outerCoreShells.length, lValues.length, idc70Values.length, idc80Values.length, gapValues.length, nValues.length); for (let i = 0; i < n; i++) { const L = lValues[i], I70 = idc70Values[i], I80 = idc80Values[i], G = gapValues[i], N = nValues[i]; if ([L, I70, I80, G, N].some(v => v === undefined || isNaN(v))) continue; result.push({ centerLegCore: centerLegCore, outerCoreShell: String(outerCoreShells[i]), L_initial: L, Idc_70: I70, Idc_80: I80, Gap: G, N: N, FoM: L * I80, }); } currentBlock = this.createEmptyBlock(); }; 
            for (const line of lines) { const trimmedLine = line.trim(); if (!trimmedLine) continue; const parts = trimmedLine.split(/\s+/); const label = parts[0].toLowerCase(); if (label.startsWith('clc_')) { flushBlock(); currentBlock.centerLegCore = parts[0]; currentBlock.outerCoreShells = parts.slice(1); } else if (label.startsWith('l_initial')) { currentBlock.lValues = parts.slice(1).map(parseFloat); } else if (label.startsWith('idc_70%')) { currentBlock.idc70Values = parts.slice(1).map(parseFloat); } else if (label.startsWith('idc_80%')) { currentBlock.idc80Values = parts.slice(1).map(parseFloat); } else if (label.startsWith('gap(mm)')) { currentBlock.gapValues = parts.slice(1).map(parseFloat); } else if (label.startsWith('n')) { currentBlock.nValues = parts.slice(1).map(parseFloat); } } 
            flushBlock(); 
            return result; 
        },
        createEmptyBlock: () => ({ centerLegCore: null, outerCoreShells: [], lValues: [], idc70Values: [], idc80Values: [], gapValues: [], nValues: [] }),
        getFilteredData() { const selectedCenterLegs = new Set(Array.from(this.elements.centerLegFilterControls.querySelectorAll('input:checked')).map(chk => chk.dataset.value)); const selectedOuterShells = new Set(Array.from(this.elements.outerCoreFilterControls.querySelectorAll('input:checked')).map(chk => chk.dataset.value)); if (selectedCenterLegs.size === 0 || selectedOuterShells.size === 0) return []; return this.parsedData.filter(d => selectedCenterLegs.has(d.centerLegCore) && selectedOuterShells.has(d.outerCoreShell)); },
        groupData: (data, groupBy) => data.reduce((groups, item) => { const key = item[groupBy]; if (!groups[key]) groups[key] = []; groups[key].push(item); return groups; }, {}),
        
        /**
         * ✨ UPDATED: Removed `this.parsedData = this.parseData();`
         * The `app.parsedData` is now set externally by the 'processBtn' listener.
         */
        updateAll() {
            // this.parsedData = this.parseData(); // <-- This line is removed.
            const allCenterLegs = [...new Set(this.parsedData.map(d => d.centerLegCore))].sort(); 
            const allOuterShells = [...new Set(this.parsedData.map(d => d.outerCoreShell))].sort((a, b) => a - b); 
            this.updateFilterControls(this.elements.centerLegFilterControls, allCenterLegs, true); 
            this.updateFilterControls(this.elements.outerCoreFilterControls, allOuterShells, true); 
            this.updateParsedDataTable(); 
            this.updateUI(); 
        },
        
        /**
         * ✨ UPDATED: Now disables/enables X/Y axis dropdowns
         * based on the selected plot type.
         */
        updateUI() { 
            const plotType = this.elements.plotType.value;
            const isSummary = plotType === 'summary';

            // Enable/disable summary-only dropdowns
            this.elements.xAxis.disabled = !isSummary;
            this.elements.yAxis.disabled = !isSummary;
            
            const baseData = this.getFilteredData(); 
            const groupedData = this.groupData(baseData, 'centerLegCore'); 
            this.updateStatsTable(groupedData); 
            this.createChart(plotType, baseData, groupedData); // Pass data to chart function
        },
        
        updateParsedDataTable() { const { parsedDataTableBody, dataCount } = this.elements; parsedDataTableBody.innerHTML = ''; dataCount.textContent = `Total of ${this.parsedData.length} data points recognized`; if (this.parsedData.length === 0) { parsedDataTableBody.innerHTML = `<tr><td colspan="8">No data recognized.</td></tr>`; return; } let rows = ''; this.parsedData.forEach(d => { rows += `<tr><td>${d.centerLegCore}</td><td>${d.outerCoreShell}</td><td>${d.L_initial.toFixed(2)}</td><td>${d.Idc_70.toFixed(2)}</td><td>${d.Idc_80.toFixed(2)}</td><td>${d.Gap.toFixed(2)}</td><td>${d.N}</td><td>${d.FoM.toFixed(1)}</td></tr>`; }); parsedDataTableBody.innerHTML = rows; },
        updateFilterControls(container, values, checkAll = false) { const checkedState = new Map(); container.querySelectorAll('input[type="checkbox"]').forEach(chk => { checkedState.set(chk.dataset.value, chk.checked); }); container.innerHTML = ''; if (!values || values.length === 0) return; values.forEach(value => { const isChecked = checkAll ? 'checked' : (checkedState.has(value) ? (checkedState.get(value) ? 'checked' : '') : 'checked'); container.innerHTML += `<div class="filter-item"><input type="checkbox" id="chk-${container.id}-${value}" data-value="${value}" ${isChecked}><label for="chk-${container.id}-${value}">${value}</label></div>`; }); },
        updateStatsTable(groupedData) { const { statsTableBody } = this.elements; statsTableBody.innerHTML = ''; if (Object.keys(groupedData).length === 0) { statsTableBody.innerHTML = '<tr><td colspan="7">No data selected. Check filters.</td></tr>'; return; } for (const group in groupedData) { const items = groupedData[group]; const calcStats = (arr) => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0; statsTableBody.innerHTML += `<tr><td><strong>${group}</strong></td><td>${items.length}</td><td>${calcStats(items.map(d => d.L_initial)).toFixed(2)}</td><td>${calcStats(items.map(d => d.Idc_70)).toFixed(2)}</td><td>${calcStats(items.map(d => d.Idc_80)).toFixed(2)}</td><td>${calcStats(items.map(d => d.FoM)).toFixed(1)}</td><td>${calcStats(items.map(d => d.Gap)).toFixed(2)}</td></tr>`; } },
        showStatus(msg, isError = false) { const { chartStatus } = this.elements; chartStatus.textContent = msg; chartStatus.style.display = 'block'; chartStatus.style.background = isError ? 'rgba(200, 0, 0, 0.7)' : 'rgba(0, 0, 0, 0.7)'; },
        
        // ==================================================================
        // ===== ✨ MODIFIED SECTION START ✨ =====
        // This function is now heavily modified to support two plot types.
        // ==================================================================
        createChart(plotType, baseData, groupedData) {
            const allCenterLegs = [...new Set(this.parsedData.map(d => d.centerLegCore))].sort();
            const isSummary = plotType === 'summary';
            
            if (this.chartInstance) {
                this.chartInstance.destroy();
            }

            // Only initialize annotations for summary plot
            if (isSummary) {
                this.chartAnnotations = [];
            }

            const ctx = this.elements.mainChart.getContext('2d');
            ctx.clearRect(0, 0, this.elements.mainChart.width, this.elements.mainChart.height);
            
            if (!baseData.length) {
                this.showStatus('No data to display.', true);
                return;
            }
            this.showStatus('Generating chart...');

            const { xAxis, yAxis } = this.elements;

            // This helper is used by both plot types
            const getLabelText = (item) => {
                if (!item) return '';
                return [
                    `${item.centerLegCore} / Shell ${item.outerCoreShell}`,
                    `L=${item.L_initial.toFixed(1)} μH`,
                    `Idc_70=${item.Idc_70.toFixed(1)} A, Idc_80=${item.Idc_80.toFixed(1)} A`,
                    `Gap=${item.Gap.toFixed(1)} mm, N=${item.N}`,
                    `FoM=${item.FoM.toFixed(1)}`
                ];
            };
           s
            // --- Annotation plugin (only for summary plot) ---
            const annotationPlugin = {
                id: 'clickAnnotations',
                afterDraw: (chart) => {
                    if (!isSummary || !this.chartAnnotations) return; // Only run for summary
                    const ctx = chart.ctx;
                    ctx.save();
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'bottom';

                    this.chartAnnotations.forEach(annotation => {
                        const model = chart.getDatasetMeta(annotation.datasetIndex).data[annotation.index];
                        if (!model) return;
                        const x = model.x + 10;
                        const y = model.y;
                        const textLines = annotation.text;
                        const lineHeight = 14;
                        const textWidth = Math.max(...textLines.map(line => ctx.measureText(line).width));
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                        ctx.fillRect(x - 3, y - (lineHeight * textLines.length) - 3, textWidth + 6, (lineHeight * textLines.length) + 6);
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x - 3, y - (lineHeight * textLines.length) - 3, textWidth + 6, (lineHeight * textLines.length) + 6);
                        ctx.fillStyle = '#333';
                        textLines.forEach((line, i) => {
                            ctx.fillText(line, x, y - (lineHeight * (textLines.length - 1 - i)));
                        });
                    });
                    ctx.restore();
                }
            };

            let datasets = [];
            let chartOptions = {};
            
            if (isSummary) {
                // --- SUMMARY PLOT LOGIC (Your original logic) ---
                datasets = Object.keys(groupedData).map(group => {
                    const coreIndex = allCenterLegs.indexOf(group);
                    const color = this.defaultColors[coreIndex % this.defaultColors.length];
                    const pointStyle = this.pointStyles[coreIndex % this.pointStyles.length];
                    const data = groupedData[group].map(item => ({
                        x: item[xAxis.value],
                        y: item[yAxis.value],
                        raw: item
                    }));
                    return {
                        label: group,
                        data,
                        backgroundColor: color,
                        borderColor: color,
                        pointStyle: pointStyle,
                        radius: 6,
                        hoverRadius: 9
                    };
                });
                
                chartOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const { datasetIndex, index } = elements[0];
                            const item = this.chartInstance.data.datasets[datasetIndex].data[index].raw;
                            const existingAnnotationIndex = this.chartAnnotations.findIndex(
                                a => a.datasetIndex === datasetIndex && a.index === index
                            );
                            if (existingAnnotationIndex > -1) {
                                this.chartAnnotations.splice(existingAnnotationIndex, 1);
                            } else {
                                this.chartAnnotations.push({
                                    datasetIndex,
                                    index,
                                    text: getLabelText(item)
                                });
                            }
                            this.chartInstance.update('none');
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { usePointStyle: true, padding: 20 } },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const item = context.raw?.raw;
                                    return getLabelText(item);
              _80: idc_80,
                                    `Gap=${item.Gap.toFixed(1)} mm, N=${item.N}`,
                                    `FoM=${item.FoM.toFixed(1)}`
                                ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: { title: { display: true, text: xAxis.options[xAxis.selectedIndex].text } },
                        y: { title: { display: true, text: yAxis.options[yAxis.selectedIndex].text } }
                    }
                };
                
            } else {
                // --- RAW L vs. Idc PLOT LOGIC (New) ---
                datasets = baseData.map(item => {
                    const coreIndex = allCenterLegs.indexOf(item.centerLegCore);
                    const color = this.defaultColors[coreIndex % this.defaultColors.length];
                    
                    // Create (x, y) points from the raw arrays
                    const dataPoints = item.rawIdc.map((idc, i) => ({ 
                        x: idc, 
                        y: item.rawInductance[i] 
                    }));
                    
                    return {
                        label: `${item.centerLegCore} / ${item.outerCoreShell}`,
                        data: dataPoints,
                        rawItem: item, // Store reference to full item for tooltip
                        type: 'line',
                        showLine: true,
                        fill: false,
          _80: idc_80,
                        `Gap=${item.Gap.toFixed(1)} mm, N=${item.N}`,
                        `FoM=${item.FoM.toFixed(1)}`
                    ];
                }
            }                borderColor: color,
                        backgroundColor: 'transparent',
                        pointRadius: 2,
                        borderWidth: 2
                    };
                });
s
                chartOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: null, // Disable click-to-annotate for this mode
                    plugins: {
                        legend: { 
                            position: 'top', 
nbsp;                     // Don't show legend if there are too many items
                            display: datasets.length <= 20 
                        },
                        tooltip: {
s                            callbacks: {
                                label: (context) => {
                                    // Get the summary data from the dataset
                                    const item = context.dataset.rawItem;
                                    return getLabelText(item);
                                }
                            }
            s             }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Idc (A)' } },
t                     y: { title: { display: true, text: 'Inductance (μH)' } }
                    }
                };
            }

            this.chartInstance = new Chart(this.elements.mainChart, {
                // Type is scatter for both, but raw plot uses showLine: true
                type: 'scatter', 
                data: { datasets },
                // Only add annotation plugin if in summary mode
                plugins: isSummary ? [annotationPlugin] : [], 
                options: chartOptions
            });
            setTimeout(() => this.elements.chartStatus.style.display = 'none', 1000);
        },
        // ==================================================================
        // ===== ✨ MODIFIED SECTION END ✨ =====
        // ==================================================================
        
        exportCSV() { const data = this.getFilteredData(); if (data.length === 0) { alert('No data selected to export.'); return; } const headers = "CenterLegCore,OuterCoreShell,L_initial(uH),Idc_70%(A),Idc_80%(A),Gap(mm),N,FoM"; const rows = data.map(d => `${d.centerLegCore},${d.outerCoreShell},${d.L_initial},${d.Idc_70},${d.Idc_80},${d.Gap},${d.N},${d.FoM.toFixed(2)}`); const csvContent = "data:text/csv;charset=utf-8," + [headers, ...rows].join("\n"); const encodedUri = encodeURI(csvContent); const link = document.createElement("a"); link.setAttribute("href", encodedUri); link.setAttribute("download", "inductance_data_export.csv"); document.body.appendChild(link); link.click(); document.body.removeChild(link); },
        exportPNG() { if (!this.chartInstance || !this.getFilteredData().length) { alert('No chart available to export.'); return; } const url = this.chartInstance.toBase64Image(); const link = document.createElement('a'); link.download = 'inductance_chart.png'; link.href = url; link.click(); }
    };
    app.init();
    // --- END: Analysis App Logic ---
});
</script>
</body>
</html>
